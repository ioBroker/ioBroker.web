/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const express     = require('express');
const fs          = require('fs');
const path        = require('path');
const utils       = require('@iobroker/adapter-core'); // Get common adapter utils
const LE          = require(utils.controllerDir + '/lib/letsencrypt.js');
const tools       = require(utils.controllerDir + '/lib/tools.js');
const mime        = require('mime-types');
const adapterName = require('./package.json').name.split('.').pop();

const ONE_MONTH_SEC = 30 * 24 * 3600;

let session;// =           require('express-session');
let cookieParser;// =      require('cookie-parser');
let bodyParser;// =        require('body-parser');
let AdapterStore;// =      require(__dirname + '/../../lib/session.js')(session);
//let passportSocketIo;// =  require(__dirname + "/lib/passport.socketio.js");
//let password;// =          require(__dirname + '/../../lib/password.js');
let passport;// =          require('passport');
let LocalStrategy;// =     require('passport-local').Strategy;
let flash;// =             require('connect-flash'); // TODO report error to user

let webServer    = null;
let store        = null;
let secret       = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let socketUrl    = '';
const cache      = {}; // cached web files
let ownSocket    = false;
let lang         = 'en';
const extensions = {};
const bruteForce = {};
let socketIoFile = null;
const webPreSettings = {};
const webByVersion = {};
let loginPage    = null;
const FORBIDDEN_CHARS = /[\][*,;'"`<>\\\s?]/g; // with space

function getAppName() {
    const parts = __dirname.replace(/\\/g, '/').split('/');
    return parts[parts.length - 1].split('.')[0];
}
utils.appName = getAppName();

// copied from here: https://github.com/component/escape-html/blob/master/index.js
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml (string) {
    const str = '' + string;
    const match = matchHtmlRegExp.exec(str);

    if (!match) {
        return str;
    }

    let escape;
    let html = '';
    let index;
    let lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escape = '&quot;';
                break;
            case 38: // &
                escape = '&amp;';
                break;
            case 39: // '
                escape = '&#39;';
                break;
            case 60: // <
                escape = '&lt;';
                break;
            case 62: // >
                escape = '&gt;';
                break;
            default:
                continue;
        }

        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }

        lastIndex = index + 1;
        html += escape;
    }

    return lastIndex !== index
        ? html + str.substring(lastIndex, index)
        : html;
}

let adapter;
function startAdapter(options) {
    options = options || {};

    Object.assign(options, {
        name: adapterName,
        objectChange: (id, obj) => {
            if (obj && obj.common && obj.common.webExtension && obj.native &&
                (extensions[id.substring('system.adapter.'.length)] ||
                    obj.native.webInstance === '*' ||
                    obj.native.webInstance === adapter.namespace
                )
            ) {
                return adapter.setForeignState(`system.adapter.${adapter.namespace}.alive`, false, true, () =>
                    adapter.terminate ? adapter.terminate(-100): process.exit(-100));
            }

            if (obj && obj.common && obj.common.webPreSettings) {
                updatePreSettings(obj);
            }

            // 'system.adapter.'.length = 15
            const _id = id.substring(15).replace(/\.\d+$/, '');
            if (obj && obj.common && obj.common.webByVersion) {
                webByVersion[_id] = obj.common.version;
            } else if (webByVersion[_id]) {
                delete webByVersion[_id];
            }

            if (!ownSocket && id === adapter.config.socketio) {
                if (obj && obj.common && obj.common.enabled && obj.native) {
                    socketUrl = ':' + obj.native.port;
                } else {
                    socketUrl = '';
                }
            }

            if (webServer && webServer.io) {
                try {
                    webServer.io.publishAll('objectChange', id, obj);
                } catch (e) {
                    adapter.log.error('Cannot objectChange to io: ' + e);
                }
            }

            if (webServer && webServer.api && adapter.config.auth) {
                try {
                    webServer.api.objectChange && webServer.api.objectChange(id, obj);
                } catch (e) {
                    adapter.log.error('Cannot call simple api: ' + e);
                }
            }

            if (id === 'system.config') {
                lang = obj && obj.common && obj.common.language ? obj.common.language : 'en';
            }

            // inform extensions
            for (let e = 0; e < extensions.length; e++) {
                try {
                    if (extensions[e].obj && extensions[e].obj.objectChange) {
                        extensions[e].obj.objectChange(id, obj);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call objectChange for "${e}": ${err}`);
                }
            }
        },
        stateChange: (id, state) => {
            if (webServer && webServer.io) {
                webServer.io.publishAll('stateChange', id, state);
            }
        },
        unload: callback => {
            try {
                adapter.log.debug(`terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                webServer.server.close();
                adapter.log.info(`terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                callback();
            } catch (e) {
                callback();
            }
        },
        ready: () => {
            // Generate secret for session manager
            adapter.getForeignObject('system.config', (err, obj) => {
                if (!err && obj) {
                    if (!obj.native || !obj.native.secret) {
                        obj.native = obj.native || {};
                        require('crypto').randomBytes(24, (ex, buf) => {
                            secret = buf.toString('hex');
                            adapter.extendForeignObject('system.config', {native: {secret: secret}});
                            main();
                        });
                    } else {
                        secret = obj.native.secret;
                        main();
                    }
                } else {
                    adapter.log.error('Cannot find object system.config');
                }
            });

            // information about connected socket.io adapter
            if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
                adapter.getForeignObject(adapter.config.socketio, (err, obj) => {
                    if (obj && obj.common && obj.common.enabled && obj.native) {
                        socketUrl = ':' + obj.native.port;
                    }
                });
                // Listen for changes
                adapter.subscribeForeignObjects(adapter.config.socketio);
            } else {
                socketUrl = adapter.config.socketio;
                ownSocket = socketUrl !== 'none';
            }

            // Read language
            adapter.getForeignObject('system.config', (err, data) => {
                if (data && data.common) {
                    lang = data.common.language || 'en';
                }
            });
        }
    });

    adapter = new utils.Adapter(options);

    return adapter;
}

function extractPreSetting(obj, attr) {
    const parts = attr.split('.');
    if (parts.length === 1) {
        if ((obj && typeof obj === 'object') || (obj !== null && obj !== undefined)) {
            return obj[attr];
        } else {
            return null;
        }
    } else {
        attr = parts.shift();
        if (obj[attr] && typeof obj[attr] === 'object') {
            return extractPreSetting(obj[attr], parts.join('.'));
        } else {
            return null;
        }
    }
}
function updatePreSettings(obj) {
    if (!obj || !obj.common) {
        return;
    }
    if (obj.common.webPreSettings) {
        for (const attr of Object.keys(obj.common.webPreSettings)) {
            webPreSettings[obj._id] = webPreSettings[obj._id] || {};
            const _attr = attr.replace(/[^\w0-9]/g, '_');
            webPreSettings[obj._id][_attr] = extractPreSetting(obj, obj.common.webPreSettings[attr]);
            if (typeof webPreSettings[obj._id][_attr] === 'object') {
                webPreSettings[obj._id][_attr] = JSON.stringify(webPreSettings[obj._id][_attr]);
            } else {
                webPreSettings[obj._id][_attr] = webPreSettings[obj._id][_attr].replace(/"/g, '\\"');
            }
        }
    } else if (webPreSettings[obj._id]) {
        delete webPreSettings[obj._id];
    }
}


function getExtensionsAndSettings(callback) {
    adapter.getObjectView('system', 'instance', null, (err, doc) => {
        if (err) {
            callback && callback(err, []);
        } else {
            if (doc.rows.length === 0) {
                callback && callback(null, []);
            } else {
                const res = [];
                for (let i = 0; i < doc.rows.length; i++) {
                    const instance = doc.rows[i].value;
                    if (instance && instance.common) {
                        if (instance.common.enabled &&
                            instance.common.webExtension &&
                        (instance.native.webInstance === adapter.namespace || instance.native.webInstance === '*')) {

                            // decrypt all native attributes listed in instance.encryptedNative
                            if (Array.isArray(instance.encryptedNative) && instance.native) {
                                instance.encryptedNative.forEach(key => {
                                    if (instance.native[key]) {
                                        instance.native[key] = tools.decrypt(secret, instance.native[key]);
                                    }
                                });
                            }

                            res.push(instance);
                        }
                        if (instance.common.webPreSettings) {
                            updatePreSettings(instance);
                        }
                        if (instance.common.webByVersion) {
                            // 'system.adapter.'.length = 15
                            const _id = doc.rows[i].value._id.substring(15).replace(/\.\d+$/, '');
                            webByVersion[_id] = instance.common.version;
                        }
                    }
                }
                callback && callback(null, res);
            }
        }
    });
}

function main() {
    getExtensionsAndSettings((err, ext) => {
        err && adapter.log.error(`Cannot read extensions: ${err}`);
        if (ext) {
            for (let e = 0; e < ext.length; e++) {
                if (ext[e] && ext[e].common) {
                    const instance = ext[e]._id.substring('system.adapter.'.length);
                    const name = instance.split('.')[0];

                    extensions[instance] = {
                        path: name + '/' + ext[e].common.webExtension,
                        config: ext[e]
                    };
                }
            }
        }

        // TODO: This whole setting of webServer global is pretty nasty, needs cleaning up.
        initWebServer(adapter.config).then(returnedServer => {
            webServer = returnedServer;
        }).catch(err => {
            adapter.log.error(`Failed to initWebServer: ${err}`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
        });
        // monitor extensions and pro keys
        adapter.subscribeForeignObjects('system.adapter.*');
    });
}

/* function readDirs(dirs, cb, result) {
    result = result || [];
    if (!dirs || !dirs.length) {
        return cb && cb(result);
    }
    const dir = dirs.shift();
    adapter.readDir(dir, '', (err, files) => {
        if (!err && files && files.length) {
            for (let f = 0; f < files.length; f++) {
                if (files[f].file.match(/\.html$/)) {
                    result.push(dir + '/' + files[f].file);
                }
            }
        }
        setImmediate(readDirs, dirs, cb, result);
    });
}
*/
let indexHtml;

function getLinkVar(_var, obj, attr, link) {
    if (attr === 'protocol') {
        attr = 'secure';
    }

    if (_var === 'ip') {
        link = link.replace(`%${_var}%`, '$host$');
    } else
    if (_var === 'instance') {
        const instance = obj._id.split('.').pop();
        link = link.replace(`%${_var}%`, instance);
    } else {
        if (obj) {
            if (attr.startsWith('native_')) {
                attr = attr.substring(7);
            }

            let val = obj.native[attr];
            if (_var === 'bind' && (!val || val === '0.0.0.0')) {
                val = '$host$';
            }

            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, val ? 'https' : 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, val);
                } else {
                    link = link.replace(`%${_var}%`, val);
                }
            }
        } else {
            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, '');
                } else {
                    link = link.replace(`%${_var}%`, '');
                }
            }
        }
    }

    return link;
}

function resolveLink(link, instanceObj, instancesMap) {
    const vars = link.match(/%(\w+)%/g);
    let _var;
    let v;
    let parts;
    let result;

    if (vars) {
        // first replace simple patterns
        for (v = vars.length - 1; v >= 0; v--) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            parts = _var.split('_');
            // like "port"
            if (_var.startsWith('native_')) {
                link = getLinkVar(_var, instanceObj, _var, link);
                vars.splice(v, 1);
            } else
            if (parts.length === 1) {
                link = getLinkVar(_var, instanceObj, parts[0], link);
                vars.splice(v, 1);
            } else
            // like "web.0_port"
            if (parts[0].match(/\.\d+$/)) {
                link = getLinkVar(_var, instancesMap['system.adapter.' + parts[0]], parts[1], link);
                vars.splice(v, 1);
            }
        }

        const links = {};
        let instances;
        const adptr = parts[0];
        // process web_port
        for (v = 0; v < vars.length; v++) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            if (_var.startsWith('native_')) {
                _var = _var.substring(7);
            }

            parts = _var.split('_');
            if (!instances) {
                instances = [];
                // TODO !
                for (let inst = 0; inst < 10; inst++) {
                    if (that.main.objects['system.adapter.' + adptr + '.' + inst]) {
                        instances.push(inst);
                    }
                }
            }

            for (let i = 0; i < instances.length; i++) {
                links[adptr + '.' + i] = {
                    instance: `${adptr}.${i}`,
                    link: getLinkVar(_var, instancesMap[`system.adapter.${adptr}.${i}`], parts[1], links[`${adptr}.${i}`] ? links[adptr + '.' + i].link : link)
                };
            }
        }
        if (instances) {
            result = [];
            let count = 0;
            let firstLink = '';
            for (const d of Object.keys(links)) {
                result[links[d].instance] = links[d].link;
                firstLink = firstLink || links[d].link;
                count++;
            }
            if (count < 2) {
                link = firstLink;
                result = null;
            }
        }
    }
    return result || link;
}

function replaceInLink(link, instanceObj, instances) {
    if (typeof link === 'object') {
        const links = JSON.parse(JSON.stringify(link));
        let first = '';
        for (const v of Object.keys(links)) {
            links[v] = resolveLink(links[v], instanceObj, instances);
            first = first || links[v];
        }
        links.__first = first;
        return links;
    } else {
        return resolveLink(link, instanceObj, instances);
    }
}

function processWelcome(welcomeScreen, isPro, adapterObj, foundInstanceIDs, list) {
    if (welcomeScreen) {
        welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
        if (Array.isArray(welcomeScreen)) {
            for (let w = 0; w < welcomeScreen.length; w++) {
                // temporary disabled for non pro
                if (!isPro && welcomeScreen[w].name === 'vis editor') {
                    continue;
                }
                if (welcomeScreen[w].localLinks && typeof welcomeScreen[w].localLinks === 'string') {
                    welcomeScreen[w].localLink = adapterObj.common.localLinks[welcomeScreen[w].localLinks];
                    if (typeof welcomeScreen[w].localLink === 'object') {
                        welcomeScreen[w].localLink = welcomeScreen[w].localLink.link;
                    }
                } else
                if (welcomeScreen[w].localLink && typeof welcomeScreen[w].localLink === 'boolean') {
                    welcomeScreen[w].localLink = adapterObj.common.localLink;
                }

                welcomeScreen[w].pro = isPro;
                if (welcomeScreen[w].localLink) {
                    if (foundInstanceIDs.length > 1) {
                        foundInstanceIDs.forEach(id => {
                            const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                            _welcomeScreen.id = id;
                            _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                            list.push(_welcomeScreen);
                        });
                    } else {
                        welcomeScreen[w].id = foundInstanceIDs[0];
                        list.push(welcomeScreen[w]);
                    }
                } else {
                    list.push(welcomeScreen[w]);
                }
            }
        } else {
            if (welcomeScreen.localLinks && typeof welcomeScreen.localLinks === 'string') {
                welcomeScreen.localLink = adapterObj.common.localLinks[welcomeScreen.localLinks];
                if (typeof welcomeScreen.localLink === 'object') {
                    welcomeScreen.localLink = welcomeScreen.localLink.link;
                }
            } else
            if (welcomeScreen.localLink && typeof welcomeScreen.localLink === 'boolean') {
                welcomeScreen.localLink = adapterObj.common.localLink;
            }
            welcomeScreen.pro = isPro;
            if (welcomeScreen.localLink) {
                if (foundInstanceIDs.length > 1) {
                    foundInstanceIDs.forEach(id => {
                        const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                        _welcomeScreen.id = id;
                        _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                        list.push(_welcomeScreen);
                    });
                } else {
                    welcomeScreen.id = foundInstanceIDs[0];
                    list.push(welcomeScreen);
                }
            } else {
                list.push(welcomeScreen);
            }
        }
    }
}

function getListOfAllAdapters(callback) {
    // read all instances
    adapter.getObjectView('system', 'instance', {}, (err, instances) => {
        adapter.getObjectView('system', 'adapter', {}, (err, adapters) => {
            try {
                const list = [];
                const mapInstance = {};
                for (let r = 0; r < instances.rows.length; r++) {
                    mapInstance[instances.rows[r].id] = instances.rows[r].value;
                }
                for (let a = 0; a < adapters.rows.length; a++) {
                    const obj = adapters.rows[a].value;
                    let found;
                    if (instances && instances.rows) {
                        found = [];
                        // find if any instance of this adapter is exists and started
                        for (let i = 0; i < instances.rows.length; i++) {
                            let id = instances.rows[i].id;
                            const ids = id.split('.');
                            ids.pop();
                            id = ids.join('.');
                            if (id === obj._id && instances.rows[i].value.common && (true || instances.rows[i].value.common.enabled || instances.rows[i].value.common.onlyWWW)) {
                                found.push(instances.rows[i].id);
                            }
                        }
                    }

                    if (found && found.length) {
                        processWelcome(obj.common.welcomeScreen, false, obj, found, list);
                        processWelcome(obj.common.welcomeScreenPro, true, obj, found, list);
                        /*if (obj.common.welcomeScreen || obj.common.welcomeScreenPro) {
                            if (obj.common.welcomeScreen) {
                                if (obj.common.welcomeScreen instanceof Array) {
                                    for (let w = 0; w < obj.common.welcomeScreen.length; w++) {
                                        // temporary disabled
                                        if (obj.common.welcomeScreen[w].name === 'vis editor') {
                                            continue;
                                        }
                                        if (obj.common.welcomeScreen[w].localLinks && typeof obj.common.welcomeScreen[w].localLinks === 'string') {
                                            obj.common.welcomeScreen[w].localLink = obj.common.localLinks[obj.common.welcomeScreen[w].localLinks];
                                            if (typeof obj.common.welcomeScreen[w].localLink === 'object') {
                                                obj.common.welcomeScreen[w].localLink = obj.common.welcomeScreen[w].localLink.link;
                                            }
                                        } else
                                        if (obj.common.welcomeScreen[w].localLink && typeof obj.common.welcomeScreen[w].localLink === 'boolean') {
                                            obj.common.welcomeScreen[w].localLink = obj.common.localLink;
                                        }

                                        if (obj.common.welcomeScreen[w].localLink) {
                                            if (found.length > 1) {
                                                found.forEach(id => {
                                                    const welcomeScreen = JSON.stringify(JSON.parse(obj.common.welcomeScreen[w]));
                                                    welcomeScreen.id = id;
                                                    list.push(welcomeScreen);
                                                });
                                            } else {
                                                obj.common.welcomeScreen[w].id = found[0];
                                                list.push(obj.common.welcomeScreen[w]);
                                            }
                                        } else {
                                            list.push(obj.common.welcomeScreen[w]);
                                        }
                                    }
                                } else {
                                    if (obj.common.welcomeScreen.localLinks && typeof obj.common.welcomeScreen.localLinks === 'string') {
                                        obj.common.welcomeScreen.localLink = obj.common.localLinks[obj.common.welcomeScreen.localLinks];
                                        if (typeof obj.common.welcomeScreen.localLink === 'object') {
                                            obj.common.welcomeScreen.localLink = obj.common.welcomeScreen.localLink.link;
                                        }
                                    } else
                                    if (obj.common.welcomeScreen.localLink && typeof obj.common.welcomeScreen.localLink === 'boolean') {
                                        obj.common.welcomeScreen.localLink = obj.common.localLink;
                                    }

                                    if (obj.common.welcomeScreen.localLink) {
                                        if (found.length > 1) {
                                            found.forEach(id => {
                                                const welcomeScreen = JSON.stringify(JSON.parse(obj.common.welcomeScreen));
                                                welcomeScreen.id = id;
                                                list.push(welcomeScreen);
                                            });
                                        } else {
                                            obj.common.welcomeScreen.id = found[0];
                                            list.push(obj.common.welcomeScreen);
                                        }
                                    } else {
                                        list.push(obj.common.welcomeScreen);
                                    }
                                }
                            }
                            if (obj.common.welcomeScreenPro) {
                                if (obj.common.welcomeScreenPro instanceof Array) {
                                    for (let ww = 0; ww < obj.common.welcomeScreenPro.length; ww++) {
                                        const tile = Object.assign({}, obj.common.welcomeScreenPro[ww]);
                                        tile.pro = true;
                                        if (tile.localLinks && typeof tile.localLinks === 'string') {
                                            tile.localLink = obj.common.localLinks[tile.localLinks];
                                            if (typeof tile.localLink === 'object') {
                                                tile.localLink = tile.localLink.link;
                                            }
                                        } else
                                        if (tile.localLink && typeof tile.localLink === 'boolean') {
                                            tile.localLink = obj.common.localLink;
                                        }
                                        if (tile.localLink) {
                                            tile.id = found;
                                        }
                                        list.push(tile);
                                    }
                                } else {
                                    const tile_ = Object.assign({}, obj.common.welcomeScreenPro);
                                    tile_.pro = true;
                                    if (tile_.localLinks && typeof tile_.localLinks === 'string') {
                                        tile_.localLink = obj.common.localLinks[tile_.localLinks];
                                        if (typeof tile_.localLink === 'object') {
                                            tile_.localLink = tile_.localLink.link;
                                        }
                                    } else
                                    if (tile_.localLink && typeof tile_.localLink === 'boolean') {
                                        tile_.localLink = obj.common.localLink;
                                    }
                                    if (tile_.localLink) {
                                        if (found.length > 1) {
                                            found.forEach(id => {
                                                const welcomeScreen = JSON.stringify(JSON.parse(obj.common.tile_));
                                                welcomeScreen.id = id;
                                                list.push(welcomeScreen);
                                            });
                                        } else {
                                            tile_.id = found[0];
                                            list.push(obj.common.welcomeScreen);
                                        }
                                    } else {
                                        list.push(tile_);
                                    }
                                }
                            }
                        }*/
                    }
                }

                if (!indexHtml && !fs.existsSync(__dirname + '/www/index.html')) {
                    return callback(null, `${__dirname}/www/index.html was not found or no access! Check the file or access rights or start the fixer: "curl -sL https://iobroker.net/fix.sh | bash -"`);
                }

                indexHtml = indexHtml || fs.readFileSync(`${__dirname}/www/index.html`).toString();

                list.sort((a, b) => {
                    const aName = (typeof a.name === 'object' ? a.name[lang] || a.name.en : a.name).toLowerCase();
                    const bName = (typeof b.name === 'object' ? b.name[lang] || b.name.en : b.name).toLowerCase();
                    if (a.order === undefined && b.order === undefined) {
                        if (aName > bName) {
                            return 1;
                        }
                        if (aName < bName) {
                            return -1;
                        }
                        return 0;
                    } else if (a.order === undefined) {
                        return -1;
                    } else if (b.order === undefined) {
                        return 1;
                    } else {
                        if (a.order > b.order) {
                            return 1;
                        }
                        if (a.order < b.order) {
                            return -1;
                        }
                        if (aName > bName) {
                            return 1;
                        }
                        if (aName < bName) {
                            return -1;
                        }
                        if (a.instance !== undefined && b.instance !== undefined) {
                            if (a.instance > b.instance) {
                                return 1;
                            }
                            if (a.instance < b.instance) {
                                return -1;
                            }
                        }

                        return 0;
                    }
                });

                // calculate localLinks
                for (let t = 0; t < list.length; t++) {
                    if (list[t].localLink) {
                        list[t].localLink = resolveLink(list[t].localLink, mapInstance[list[t].id], mapInstance);
                    }
                }

                let text = `systemLang = "${lang}";\n`;
                text += `list = ${JSON.stringify(list, null, 2)};\n`;

                // if login
                text += `let authEnabled = ${adapter.config.auth};\n`;

                callback(null, indexHtml.replace('// -- PLACE THE LIST HERE --', text));
            } catch (e) {
                callback(e);
            }
        });
    });

}

function getInfoJs(settings) {
    const result = [
        `var socketUrl = "${socketUrl}";`,
        `var socketSession = "";`,
        `window.sysLang = "${lang}";`,
        `window.socketForceWebSockets = ${settings.forceWebSockets ? 'true' : 'false'};`
    ];
    for (const id of Object.keys(webPreSettings)) {
        if (webPreSettings[id]) {
            for (const attr of Object.keys(webPreSettings[id])) {
                result.push(`window.${attr} = "${webPreSettings[id][attr]}";`);
            }
        }
    }
    return result.join(' ');
}

function prepareLoginTemplate() {
    let def =
        '            font: 13px/20px \'Lucida Grande\', Tahoma, Verdana, sans-serif;\n' +
        '            color: #404040;\n' +
        '            background-color: #0ae;\n' +
        '            background-image: -webkit-gradient(linear, 0 0, 0 100%, color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.5, transparent), to(transparent));\n' +
        '            background-image: -webkit-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -moz-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -ms-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -o-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-size: 50px 50px;\n'
    ;
    const template = fs.readFileSync(__dirname + '/www/login/index.html').toString('utf8');
    if (adapter.config.loginBackgroundColor) {
        def = `background-color: ${adapter.config.loginBackgroundColor};\n`;
    }
    if (adapter.config.loginBackgroundImage) {
        def += `            background-image: url(../${adapter.namespace}/login-bg.png);\n`;
    }
    return template.replace('background: black;', def);
}

function initAuth(server, settings) {
    session =          require('express-session');
    cookieParser =     require('cookie-parser');
    bodyParser =       require('body-parser');
    AdapterStore =     require(utils.controllerDir + '/lib/session.js')(session, settings.ttl);
    // passportSocketIo = require('passport.socketio');
    // password =         require(utils.controllerDir + '/lib/password.js');
    passport =         require('passport');
    LocalStrategy =    require('passport-local').Strategy;
    flash =            require('connect-flash'); // TODO report error to user

    store = new AdapterStore({adapter: adapter});

    passport.use(new LocalStrategy(
        function (username, password, done) {
            username = (username || '').toString().replace(FORBIDDEN_CHARS, '_').replace(/\s/g, '_').replace(/\./g, '_').toLowerCase();

            if (bruteForce[username] && bruteForce[username].errors > 4) {
                let minutes = (new Date().getTime() - bruteForce[username].time);
                if (bruteForce[username].errors < 7) {
                    if ((new Date().getTime() - bruteForce[username].time) < 60000) {
                        minutes = 1;
                    } else {
                        minutes = 0;
                    }
                } else
                if (bruteForce[username].errors < 10) {
                    if ((new Date().getTime() - bruteForce[username].time) < 180000) {
                        minutes = Math.ceil((180000 - minutes) / 60000);
                    } else {
                        minutes = 0;
                    }
                } else
                if (bruteForce[username].errors < 15) {
                    if ((new Date().getTime() - bruteForce[username].time) < 600000) {
                        minutes = Math.ceil((600000 - minutes) / 60000);
                    } else {
                        minutes = 0;
                    }
                } else
                if ((new Date().getTime() - bruteForce[username].time) < 3600000) {
                    minutes = Math.ceil((3600000 - minutes) / 60000);
                } else {
                    minutes = 0;
                }

                if (minutes) {
                    return done(`Too many errors. Try again in ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}.`, false);
                }
            }
            adapter.checkPassword(username, password, res => {
                if (!res) {
                    bruteForce[username] = bruteForce[username] || {errors: 0};
                    bruteForce[username].time = new Date().getTime();
                    bruteForce[username].errors++;
                } else if (bruteForce[username]) {
                    delete bruteForce[username];
                }

                if (res) {
                    return done(null, username);
                } else {
                    return done(null, false);
                }
            });
        }
    ));
    passport.serializeUser((user, done) => done(null, user));

    passport.deserializeUser((user, done) => done(null, user));

    server.app.use(cookieParser());
    server.app.use(bodyParser.urlencoded({
        extended: true
    }));
    server.app.use(bodyParser.json());
    server.app.use(bodyParser.text());
    server.app.use(session({
        secret:            secret,
        saveUninitialized: true,
        resave:            true,
        cookie:            {maxAge: settings.ttl * 1000},
        store:             store
    }));
    server.app.use(passport.initialize());
    server.app.use(passport.session());
    server.app.use(flash());
}

/**
 * Send response to a byte ranges request
 *
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {Buffer} buffer - buffer to be sent
 * @returns {void}
 */
function sendRange(req, res, buffer) {
    /** @type {Record<string, number>[]} */
    const ranges = req.range(buffer.length);

    if (ranges.length > 1) {
        adapter.log.warn('Multiple ranges currently not supported, sending whole buffer');
        res.status(200).send(buffer);
        return;
    }

    // This is for <video> tag on iOS Safari, only one range is used by Safari, so this is enough for now
    const range = ranges[0] || {start: 0, end: buffer.length};
    res.set('Content-Range', `bytes ${range.start}-${range.end}/${buffer.length}`);
    const buf = buffer.slice(range.start, range.end + 1);
    res.set('Content-Length', buf.length);
    res.status(206).send(buf);
}

//settings: {
//    "port":   8080,
//    "auth":   false,
//    "secure": false,
//    "bind":   "0.0.0.0", // "::"
//    "cache":  false
//}
async function initWebServer(settings) {

    if (settings.secure) {
        // Load certificates and/or get Lets Encrypt config.
        const certObj = await adapter.getCertificatesAsync();
        settings.certificates = certObj[0];
        settings.leConfig = certObj[1];
    }

    const server = {
        app:       null,
        server:    null,
        io:        null,
        settings:  settings
    };
    adapter.subscribeForeignObjects('system.config');

    settings.ttl = parseInt(settings.ttl, 10) || 3600;
    if (!settings.whiteListEnabled && settings.whiteListSettings) {
        delete settings.whiteListSettings;
    }

    settings.defaultUser = settings.defaultUser || 'system.user.admin';
    if (!settings.defaultUser.startsWith('system.user.')) {
        settings.defaultUser = 'system.user.' + settings.defaultUser;
    }

    if (settings.port) {
        if (settings.secure && !settings.certificates) {
            return null;
        }
        server.app = express();

        server.app.disable('x-powered-by');
        // enable use of i-frames together with HTTPS
        // todo find the admin port and bind and use it here "ALLOW-FROM ipbind:port"
        // try to add "Content-Security-Policy: frame-ancestors 'self' example.com *.example.net ;"
        /*
        server.app.get('/*', (req, res, next) => {
            res.header('X-Frame-Options' , 'SAMEORIGIN');
            next(); // http://expressjs.com/guide.html#passing-route control
        });
        */

        if (settings.auth) {
            initAuth(server, settings);

            /**
             * Authenticates at the server with the given username and password provided in req
             *
             * @param {object} req - request object having properties username and password
             * @param {object} res - response object
             * @param {function} next - express next function
             * @param {string} redirect - redirect path
             * @param {string} origin - origin path
             */
            const authenticate = (req, res, next, redirect, origin) => {
                passport.authenticate('local', (err, user) => {
                    if (err) {
                        adapter.log.warn(`Cannot login user: ${err}`);
                        return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                    }
                    if (!user) {
                        return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                    }
                    req.logIn(user, err => {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                        if (req.body.stayLoggedIn) {
                            req.session.cookie.maxAge = settings.ttl > ONE_MONTH_SEC ? settings.ttl * 1000 : ONE_MONTH_SEC * 1000;
                        } else {
                            req.session.cookie.maxAge = settings.ttl * 1000;
                        }
                        return res.redirect(redirect);
                    });
                })(req, res, next);
            };

            /**
             * Auto Logon if possible else it will redirect or return Basic Auth information if activated
             *
             * @param {Request} req - request object
             * @param {Response} res - response object
             * @param {function} next - next function of express
             * @param {string} redirect - redirect path
             * @returns {void|*|Response}
             */
            const autoLogonOrRedirectToLogin = (req, res, next, redirect) => {
                if (!settings.whiteListSettings) {
                    if (/\.css(\?.*)?$/.test(req.originalUrl)) {
                        return res.status(200).send('');
                    } else
                    if (/\.js(\?.*)?$/.test(req.originalUrl)) {
                        // return always valid js file for js, because if cache is active it leads to errors
                        const parts = req.originalUrl.split('/');
                        parts.shift();

                        // const ref = parts.join('/');

                        // if request for web/lib, ignore it, because no redirect information
                        if (parts[0] === 'lib') {
                            return res.status(200).send('');
                        } else {
                            return res.status(200).send('document.location="/login/index.html?href=" + encodeURI(location.href.replace(location.origin, ""));');
                        }
                    } else if (adapter.config.basicAuth) {
                        // if basic auth active, we tell it by sending header with 401 status
                        res.set('WWW-Authenticate', `Basic realm="Access to ioBroker web", charset="UTF-8"`);
                        return res.status(401).send('Basic Authentication has been aborted. You have to reload the page.');
                    } else {
                        return res.redirect(redirect);
                    }
                }

                // if whitelist is used
                const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
                const whiteListIp = server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
                adapter.log.silly(`whiteListIp ${whiteListIp}`);
                if (!whiteListIp || settings.whiteListSettings[whiteListIp].user === 'auth') {
                    if (/\.css(\?.*)?$/.test(req.originalUrl)) {
                        return res.status(200).send('');
                    } else if (/\.js(\?.*)?$/.test(req.originalUrl)) {
                        // return always valid js file for js, because if cache is active it leads to errors
                        const parts = req.originalUrl.split('/');
                        parts.shift();
                        // const ref = parts.join('/');
                        if (parts[0] === 'lib') {
						    return res.status(200).send('');
                        } else {
                            return res.status(200).send('document.location="/login/index.html?href=" + encodeURI(location.href.replace(location.origin, ""));');
                        }
                    } else if (adapter.config.basicAuth) {
                        // if basic auth active, we tell it by sending header with 401 status
                        res.set('WWW-Authenticate', `Basic realm="Access to ioBroker web", charset="UTF-8"`);
                        return res.status(401).send('Basic Authentication has been aborted. You have to reload the page.');
                    } else {
                        return res.redirect(redirect);
                    }
                }
                req.logIn(settings.whiteListSettings[whiteListIp].user, err => next(err));
            };

            server.app.post('/login', (req, res, next) => {
                let redirect = '../';
                let parts;
                req.body = req.body || {};
                const origin = req.body.origin || '?href=%2F';
                if (origin) {
                    parts = origin.split('=');
                    if (parts.length > 1 && parts[1]) {
                        redirect = decodeURIComponent(parts[1]);
                        // if some invalid characters in redirect
                        if (redirect.match(/[^-_a-zA-Z0-9&%?./]/)) {
                            redirect = '../';
                        }
                    }
                }

                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                if (req.body.username && settings.addUserName && redirect.indexOf('?') === -1) {
                    parts = redirect.split('#');
                    parts[0] += '?' + req.body.username;
                    redirect = parts.join('#');
                }

                authenticate(req, res, next, redirect, origin);
            });

            server.app.get('/logout', (req, res) => {
                req.logout();
                res.redirect('/login/index.html');
            });

            // route middleware to make sure a user is logged in
            server.app.use((req, res, next) => {
                // return favicon always
                if (req.originalUrl.startsWith('/login/favicon.ico')) {
                    res.set('Content-Type', 'image/x-icon');
                    return res.send(fs.readFileSync(__dirname + '/www/login/favicon.ico'));
                }
                // if cache.manifest got back not 200 it makes an error
                if (req.isAuthenticated() ||
                    /web\.\d+\/login-bg\.png(\?.*)?$/.test(req.originalUrl) ||
                    /cache\.manifest(\?.*)?$/.test(req.originalUrl) ||
                    /^\/login\//.test(req.originalUrl) ||
                    /\.ico(\?.*)?$/.test(req.originalUrl)
                ) {
                    return next();
                } else if (adapter.config.basicAuth && typeof req.headers.authorization === 'string' && req.headers.authorization.startsWith('Basic')) {
                    // not logged in yet and basic auth is active + header present
                    const b64auth = req.headers.authorization.split(' ')[1];
                    const [login, password] = Buffer.from(b64auth, 'base64').toString().split(':');

                    req.body = req.body || {};

                    req.body.username = login;
                    req.body.password = password;
                    req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                    const origin = req.body.origin || '?href=%2F';
                    const redirect = req.originalUrl;

                    authenticate(req, res, next, redirect, origin);
                } else {
                    // not logged in yet, redirect, auto login or send 401 if basicAuth activated
                    autoLogonOrRedirectToLogin(req, res, next, `/login/index.html?href=${encodeURIComponent(req.originalUrl)}`);
                }
            });
        } else {
            server.app.get('/login', (req, res) => res.redirect('/'));
            server.app.get('/logout', (req, res) => res.redirect('/'));

            if (settings.whiteListEnabled) {
                initAuth(server, settings);
                server.app.use((req, res, next) => {
                    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
                    const whiteListIp = server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
                    adapter.log.silly('whiteListIp ' + whiteListIp);
                    if (whiteListIp) {
                        req.logIn(settings.whiteListSettings[whiteListIp].user, err =>
                            next(err));
                    } else {
                        req.logIn(settings.defaultUser.substr(12), err => // cut "system.user."
                            next(err));
                    }
                });
            }
        }

        if (!settings.disableStates) {
            adapter.log.debug('Activating states & socket info');
            // Init read from states
            server.app.get('/state/*', (req, res) => {
                try {
                    const fileName = req.url.split('/', 3)[2].split('?', 2);
                    adapter.getForeignObject(fileName[0], (err, obj) => {
                        let contentType = 'text/plain';
                        if (obj && obj.common.type === 'file')  {
                            contentType = mime.lookup(fileName[0]);
                        }
                        adapter.getBinaryState(fileName[0], {user: req.user ? 'system.user.' + req.user : settings.defaultUser}, (err, obj) => {
                            if (!err && obj !== null && obj !== undefined) {
                                if (obj && typeof obj === 'object' && obj.val !== undefined && obj.ack !== undefined) {
                                    res.set('Content-Type', 'application/json');
                                } else {
                                    res.set('Content-Type', contentType || 'text/plain');
                                }
                                res.status(200).send(obj);
                            } else {
                                res.status(404).send(`404 Not found. File ${escapeHtml(fileName[0])} not found`);
                            }
                        });
                    });
                } catch (e) {
                    res.status(500).send(`500. Error${e}`);
                }
            });

            server.app.get('*/_socket/info.js', (req, res) => {
                res.set('Content-Type', 'application/javascript');
                res.status(200).send(getInfoJs(settings));
            });
        }

        // Enable CORS
        if (settings.socketio) {
            server.app.use((req, res, next) => {
                res.header('Access-Control-Allow-Origin', '*');
                res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
                res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With, *');

                // intercept OPTIONS method
                if ('OPTIONS' === req.method) {
                    res.status(200).send(200);
                } else {
                    next();
                }
            });
        }

        const appOptions = {};
        if (settings.cache) {
            appOptions.maxAge = 30758400000; // one year
        }

        try {
            if (typeof LE.createServerAsync === 'function') {
                server.server = await LE.createServerAsync(server.app, settings, settings.certificates, settings.leConfig, adapter.log, adapter);
            } else {
                server.server = LE.createServer(server.app, settings, settings.certificates, settings.leConfig, adapter.log);
            }
        } catch (err) {
            adapter.log.error(`Cannot create webserver: ${err}`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }
        if (!server.server) {
            adapter.log.error(`Cannot create webserver`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }

        server.server.__server = server;
    } else {
        adapter.log.error('port missing');
        adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    }

    if (server.server) {
        let serverListening = false;
        let serverPort;
        server.server.on('error', e => {
            if (e.toString().includes('EACCES') && serverPort <= 1024) {
                adapter.log.error(`node.js process has no rights to start server on the port ${serverPort}.\n` +
                    `Do you know that on linux you need special permissions for ports under 1024?\n` +
                    `You can call in shell following scrip to allow it for node.js: "iobroker fix"`
                );
            } else {
                adapter.log.error(`Cannot start server on ${settings.bind || '0.0.0.0'}:${serverPort}: ${e}`);
            }
            if (!serverListening) {
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
        });

        settings.port = parseInt(settings.port, 10) || 8082;
        serverPort = settings.port;

        adapter.getPort(settings.port, port => {
            port = parseInt(port, 10);
            if (port !== settings.port && !settings.findNextPort) {
                adapter.log.error(`port ${settings.port} already in use`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
            serverPort = port;
            server.server.listen(port, (!settings.bind || settings.bind === '0.0.0.0') ? undefined : settings.bind || undefined, () => {
                serverListening = true;
            });

            adapter.log.info(`http${settings.secure ? 's' : ''} server listening on port ${port}`);
        });
    }

    // Activate integrated socket
    if (ownSocket) {
        adapter.log.debug('Activating IOSocket');
        const socketSettings = JSON.parse(JSON.stringify(settings));
        // Authentication checked by server itself
        socketSettings.auth = settings.auth;
        socketSettings.secret = secret;
        socketSettings.store = store;
        socketSettings.ttl = settings.ttl || 3600;
        socketSettings.forceWebSockets = settings.forceWebSockets || false;

        try {
            const IOSocket = require(`${utils.appName}.socketio/lib/socket.js`);
            server.io = new IOSocket(server.server, socketSettings, adapter);
        } catch (err) {
            adapter.log.error('Initialization of integrated socket.io failed. Please reinstall the web adapter.');
        }
    }

    if (!settings.disableExtensions) {
        adapter.log.debug('Activating extensions');
        // activate extensions
        Object.keys(extensions).forEach(e => {
            try {
                // for debug purposes try to load file in current directory "/lib/file.js" (elsewise node.js cannot debug it)
                const parts = extensions[e].path.split('/');
                parts.shift();
                let extAPI;
                if (fs.existsSync(__dirname + '/' + parts.join('/'))) {
                    extAPI = require(__dirname + '/' + parts.join('/'));
                } else {
                    extAPI = require(utils.appName + '.' + extensions[e].path);
                }

                extensions[e].obj = new extAPI(server.server, {secure: settings.secure, port: settings.port}, adapter, extensions[e].config, server.app);
                adapter.log.info(`Connect extension "${extensions[e].path}"`);
            } catch (err) {
                adapter.log.error(`Cannot start extension "${e}": ${err}`);
            }
        });
    }

    // Activate integrated simple API
    if (settings.simpleapi) {
        adapter.log.debug('Activating simple API');
        try {
            const SimpleAPI = require(`${utils.appName}.simple-api/lib/simpleapi.js`);

            server.api = new SimpleAPI(server.server, {secure: settings.secure, port: settings.port}, adapter);
        } catch (e) {
            adapter.log.error(`Cannot find simple api module! ${e}`);
        }
    }

    if (server.app && !settings.disableFilesObjects) {
        adapter.log.debug('Activating web files from objectDB');
        // deliver web files from objectDB
        server.app.use('/', (req, res) => {

            let url = decodeURI(req.url);
            // remove all ../
            // important: Linux does not normalize "\" but fs.readFile accepts it as '/'
            url = path.normalize(url.replace(/\\/g, '/')).replace(/\\/g, '/');
            // remove '////' at start and let only one
            if (url[0] === '/' && url[1] === '/') {
                let i = 2;
                while (url[i] === '/') {
                    i++;
                }
                url = url.substring(i - 1);
            }
            if ((url[0] === '.' && url[1] === '.') || (url[0] === '/' && url[1] === '.' && url[2] === '.')) {
                return res.status(404).send('Not found');
            }

            if (server.api && server.api.checkRequest(url)) {
                return server.api.restApi(req, res);
            }

            if (url === '/' || url === '/index.html') {
                return getListOfAllAdapters((err, data) => {
                    if (err) {
                        res.status(500).send(`500. Error${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`);
                    } else {
                        res
                            .set('Content-Type', 'text/html')
                            .status(200)
                            .send(data);
                    }
                });
            }

            // add index.html
            url = url.replace(/\/($|\?|#)/, '/index.html$1');

            if (url.match(/^\/adapter\//)) {
                // add .admin to adapter name
                url = url.replace(/^\/adapter\/([a-zA-Z0-9-_]+)\//, '/$1.admin/');
            }

            if (url.match(/^\/lib\//)) {
                url = '/' + adapter.name + url;
            }
            if (url.match(/^\/admin\//)) {
                url = '/' + adapter.name + url;
            }
            url = url.split('/');
            // Skip first /
            url.shift();
            // Get ID
            const id = url.shift();
            const versionPrefix = url[0];
            url = url.join('/');
            const pos = url.indexOf('?');
            let noFileCache;
            if (pos !== -1) {
                url = url.substring(0, pos);
                // disable file cache if request like /vis/files/picture.png?noCache
                noFileCache = true;
            }

            // get adapter name
            if (webByVersion[id]) {
                if (!versionPrefix || !versionPrefix.match(/^\d+\.\d+.\d+$/)) {
                    // redirect to version
                    res.set('location', `/${id}/${webByVersion[id]}/${url}`);
                    return res.status(301).send();
                }
            }

            if (settings.cache && cache[`${id}/${url}`] && !noFileCache) {
                res.contentType(cache[`${id}/${url}`].mimeType);
                if (req.headers.range) {
                    sendRange(req, res, cache[`${id}/${url}`].buffer);
                } else {
                    res.status(200).send(cache[`${id}/${url}`].buffer);
                }
            } else {
                if (id === 'login' && url === 'index.html') {
                    loginPage = loginPage || prepareLoginTemplate();
                    const buffer = loginPage;

                    if (buffer === null || buffer === undefined) {
                        res.contentType('text/html');
                        res.status(200).send('File ' + escapeHtml(url) + ' not found', 404);
                    } else {
                        // Store file in cache
                        if (settings.cache) {
                            cache[id + '/' + url] = {buffer: buffer.toString(), mimeType: 'text/html'};
                        }
                        res.contentType('text/html');
                        res.status(200).send(buffer.toString());
                    }
                } else {
                    // special solution for socket.io
                    if (socketIoFile !== false && (url.startsWith('socket.io.js') || url.match(/\/socket\.io\.js(\?.*)?$/))) {
                        if (socketIoFile) {
                            res.contentType('text/javascript');
                            return res.status(200).send(socketIoFile);
                        } else {
                            try {
                                const dir = require.resolve('socket.io-client');
                                const fileDir = path.join(path.dirname(dir), '../dist/');
                                if (fs.existsSync(fileDir + 'socket.io.min.js')) {
                                    socketIoFile = fs.readFileSync(fileDir + 'socket.io.min.js');
                                } else {
                                    socketIoFile = fs.readFileSync(fileDir + 'socket.io.js');
                                }
                            } catch (e) {
                                try {
                                    socketIoFile = fs.readFileSync(`${__dirname}/www/lib/js/socket.io.js`);
                                } catch (e) {
                                    adapter.log.error(`Cannot read socket.io.js: ${e}`);
                                    socketIoFile = false;
                                }
                            }
                            if (socketIoFile) {
                                res.contentType('text/javascript');
                                return res.status(200).send(socketIoFile);
                            }
                        }
                    }

                    adapter.readFile(id, webByVersion[id] && versionPrefix ? url.substring(versionPrefix.length + 1) : url, {user: req.user ? 'system.user.' + req.user : settings.defaultUser, noFileCache: noFileCache}, (err, buffer, mimeType) => {
                        if (buffer === null || buffer === undefined || err) {
                            res.contentType('text/html');
                            res.status(404).send(`File ${escapeHtml(url)} not found: ${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`);
                        } else {
                            mimeType = mimeType || mime.lookup(url) || 'text/javascript';

                            // Store file in cache
                            if (settings.cache) {
                                cache[`${id}/${url}`] = {buffer, mimeType};
                            }

                            res.contentType(mimeType);

                            if (req.headers.range) {
                                sendRange(req, res, buffer);
                            } else {
                                res.status(200).send(buffer);
                            }
                        }
                    });
                }
            }
        });
    }

    if (server.server) {
        return server;
    } else {
        return null;
    }
}

// If started as allInOne/compact mode => return function to create instance
if (module && module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}

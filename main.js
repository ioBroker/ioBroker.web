/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const express = require('express');
const fs = require('node:fs');
const path = require('node:path');
const utils = require('@iobroker/adapter-core'); // Get common adapter utils
const IoBWebServer = require('@iobroker/webserver');
const mime = require('mime-types');
const adapterName = require('./package.json').name.split('.').pop();
const compression = require('compression');

const ONE_MONTH_SEC = 30 * 24 * 3600;

let session; // =           require('express-session');
let cookieParser; // =      require('cookie-parser');
let bodyParser; // =        require('body-parser');
let AdapterStore; // =      require(__dirname + '/../../lib/session.js')(session);
let passport; // =          require('passport');
let LocalStrategy; // =     require('passport-local').Strategy;
let flash; // =             require('connect-flash'); // TODO report error to user
let checkTimeout;
let vendorPrefix;

let webServer = null;
let store = null;
let secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let socketUrl = '';
const cache = {}; // cached web files
let ownSocket = false;
let lang = 'en';
const extensions = {};
const bruteForce = {};
let socketIoFile = null;
const webPreSettings = {};
const webByVersion = {};
let loginPage = null;
const FORBIDDEN_CHARS = /[\][*,;'"`<>\\\s?]/g; // with space
let groups = null;
let users = null;

const LOGIN_PAGE = '/login/index.html';
const wwwDir = 'www';

function getAppName() {
    const parts = __dirname.replace(/\\/g, '/').split('/');
    return parts[parts.length - 1].split('.')[0].toLowerCase();
}
utils.appName = getAppName();

// copied from here: https://github.com/component/escape-html/blob/master/index.js
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml (string) {
    const str = '' + string;
    const match = matchHtmlRegExp.exec(str);

    if (!match) {
        return str;
    }

    let escape;
    let html = '';
    let index;
    let lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escape = '&quot;';
                break;
            case 38: // &
                escape = '&amp;';
                break;
            case 39: // '
                escape = '&#39;';
                break;
            case 60: // <
                escape = '&lt;';
                break;
            case 62: // >
                escape = '&gt;';
                break;
            default:
                continue;
        }

        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }

        lastIndex = index + 1;
        html += escape;
    }

    return lastIndex !== index
        ? html + str.substring(lastIndex, index)
        : html;
}

async function getSocketUrl(obj) {
    if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
        obj = obj || (await adapter.getForeignObjectAsync(adapter.config.socketio));
        if (obj && obj.common && !obj.common.enabled) {
            const state = await adapter.getForeignStateAsync(`${adapter.config.socketio}.alive`);
            if (state && state.val) {
                return `:${obj.native.port}`;
            }
        } else if (obj && obj.common && obj.common.enabled && obj.native) {
            return `:${obj.native.port}`;
        }
    }

    return '';
}

let adapter;
function startAdapter(options) {
    options = options || {};

    Object.assign(options, {
        name: adapterName,
        objectChange: (id, obj) => {
            if (groups && id.startsWith('system.group.')) {
                if (obj) {
                    groups[id] = obj;
                } else {
                    delete groups[id];
                }
            }
            if (users && id.startsWith('system.user.')) {
                if (obj) {
                    users[id] = obj;
                } else {
                    delete users[id];
                }
            }

            if (id.startsWith('system.adapter')) {
                if (obj && obj.common && obj.common.webExtension && obj.native &&
                    (extensions[id.substring('system.adapter.'.length)] ||
                        obj.native.webInstance === '*' ||
                        obj.native.webInstance === adapter.namespace
                    )
                ) {
                    return adapter.setForeignState(`system.adapter.${adapter.namespace}.alive`, false, true, () =>
                        adapter.terminate ? adapter.terminate(-100) : process.exit(-100));
                }

                // 'system.adapter.'.length = 15
                const _id = id.substring(15).replace(/\.\d+$/, '');
                if (obj && obj.common && obj.common.webByVersion) {
                    webByVersion[_id] = obj.common.version;
                } else if (webByVersion[_id]) {
                    delete webByVersion[_id];
                }
            }

            if (obj && obj.common && obj.common.webPreSettings) {
                updatePreSettings(obj);
            }

            if (!ownSocket && id === adapter.config.socketio) {
                getSocketUrl(obj)
                    .then(_socketUrl => {
                        socketUrl = _socketUrl;
                        adapter.log.info(`SocketURL now "${socketUrl}"`);
                    });
            }

            if (id === 'system.config' && !adapter.config.language) {
                lang = obj && obj.common && obj.common.language ? obj.common.language : 'en';
            }

            if (webServer && webServer.io) {
                try {
                    webServer.io.publishAll('objectChange', id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot objectChange to io: ${e}`);
                }
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.objectChange && webServer.api.objectChange(id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot call objectChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.objectChange === 'function') {
                        extensions[instance].obj.objectChange(id, obj);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call objectChange for "${instance}": ${err.message}`);
                }
            });
        },
        stateChange: (id, state) => {
            if (webServer && webServer.io) {
                webServer.io.publishAll('stateChange', id, state);
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.stateChange && webServer.api.stateChange(id, state);
                } catch (e) {
                    adapter.log.error(`Cannot call stateChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.stateChange === 'function') {
                        extensions[instance].obj.stateChange(id, state);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call stateChange for "${instance}": ${err.message}`);
                }
            });
        },
        fileChange: (id, fileName, size) => {
            if (webServer && webServer.io) {
                webServer.io.publishFileAll(id, fileName, size);
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.fileChange && webServer.api.fileChange(id, fileName, size);
                } catch (e) {
                    adapter.log.error(`Cannot call fileChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.fileChange === 'function') {
                        extensions[instance].obj.fileChange(id, fileName, size);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call fileChange for "${instance}": ${err.message}`);
                }
            });
        },
        message: obj => {
            if (!obj || obj.command !== 'im') { // if not instance message
                return;
            }

            if (webServer.io && webServer.io) {
                // to make messages shorter, we code the answer as:
                // m - message type
                // s - socket ID
                // d - data

                webServer.io.publishInstanceMessageAll(obj.from, obj.message.m, obj.message.s, obj.message.d);
            }
        },
        unload: callback => {
            checkTimeout && adapter.clearTimeout(checkTimeout);
            checkTimeout = null;

            try {
                const promises = [];

                if (adapter.setStateAsync) {
                    promises.push(adapter.setStateAsync('info.connected', '', true));
                    promises.push(adapter.setStateAsync('info.connection', false, true));
                }

                Object.keys(extensions).forEach(instance => {
                    try {
                        if (extensions?.[instance]?.obj?.unload) {
                            const promise = extensions[instance].obj.unload();
                            if (promise && typeof promise === 'object' && typeof promise.then === 'function') {
                                promises.push(promise
                                    .catch(e =>
                                        adapter && adapter.log && adapter.log.error(`Cannot unload web extension "${instance}": ${e}`)));
                            }
                        }
                    } catch (e) {
                        adapter && adapter.log && adapter.log.error(`Cannot unload web extension "${instance}": ${e}`);
                    }
                });

                let timeout;
                if (promises.length) {
                    timeout = adapter.setTimeout(() => {
                        timeout = null;
                        adapter && adapter.log && adapter.log.warn(`Timeout by termination of web-extensions!`);
                        webServer && webServer.settings && adapter && adapter.log && adapter.log.debug(`terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                        webServer && webServer.io && webServer.io.close();
                        webServer && webServer.server && webServer.server.close();
                        webServer && webServer.settings && adapter && adapter.log && adapter.log.info(`terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                        callback && callback();
                    }, 500);
                }

                Promise.all(promises)
                    .catch(e => adapter && adapter.log && adapter.log.error(`Cannot unload web extensions: ${e}`))
                    .then(() => {
                        if (!promises.length || timeout) {
                            adapter.clearTimeout(timeout);
                            timeout = null;
                            webServer && webServer.settings && adapter && adapter.log && adapter.log.debug(`terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                            webServer && webServer.io && webServer.io.close();
                            webServer && webServer.server && webServer.server.close();
                            webServer && webServer.settings && adapter && adapter.log && adapter.log.info(`terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                            callback && callback();
                        }
                    });
            } catch (e) {
                callback();
            }
        },
        ready: async () => {
            // Generate secret for session manager
            const systemConfig = await adapter.getForeignObjectAsync('system.config');

            if (systemConfig) {
                if (!systemConfig.native || !systemConfig.native.secret) {
                    systemConfig.native = systemConfig.native || {};
                    const buf = await new Promise(resolve => require('crypto').randomBytes(24, (ex, buf) => resolve(buf)));
                    secret = buf.toString('hex');
                    await adapter.extendForeignObjectAsync('system.config', {native: {secret}});
                } else {
                    secret = systemConfig.native.secret;
                }
            } else {
                adapter.log.error('Cannot find object system.config');
            }

            let uuid = null;
            try {
                uuid = await adapter.getForeignObjectAsync('system.meta.uuid');
            } catch (e) {
                adapter.log.warn(`Cannot read UUID: ${e}`);
            }
            vendorPrefix = systemConfig?.native?.vendor?.uuidPrefix || (uuid?.native?.uuid?.length > 36 ? uuid.native.uuid.substring(0, 2) : '');

            // information about connected socket.io adapter
            if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
                socketUrl = await getSocketUrl();
                // Listen for changes
                await adapter.subscribeForeignObjectsAsync(adapter.config.socketio);
            } else {
                socketUrl = adapter.config.socketio;
                ownSocket = socketUrl !== 'none';
            }

            // Read language
            if (adapter.config.language) {
                lang = adapter.config.language;
            } else if (systemConfig && systemConfig.common) {
                lang = systemConfig.common.language || 'en';
            }

            main();
        }
    });

    adapter = new utils.Adapter(options);

    return adapter;
}

function extractPreSetting(obj, attr) {
    const parts = attr.split('.');
    if (parts.length === 1) {
        if ((obj && typeof obj === 'object') || (obj !== null && obj !== undefined)) {
            return obj[attr];
        } else {
            return null;
        }
    } else {
        attr = parts.shift();
        if (obj[attr] && typeof obj[attr] === 'object') {
            return extractPreSetting(obj[attr], parts.join('.'));
        } else {
            return null;
        }
    }
}

function updatePreSettings(obj) {
    if (!obj || !obj.common) {
        return;
    }
    if (obj.common.webPreSettings) {
        for (const attr of Object.keys(obj.common.webPreSettings)) {
            webPreSettings[obj._id] = webPreSettings[obj._id] || {};
            const _attr = attr.replace(/[^\w0-9]/g, '_');
            webPreSettings[obj._id][_attr] = extractPreSetting(obj, obj.common.webPreSettings[attr]);
            if (typeof webPreSettings[obj._id][_attr] === 'object') {
                webPreSettings[obj._id][_attr] = JSON.stringify(webPreSettings[obj._id][_attr]);
            } else {
                webPreSettings[obj._id][_attr] = webPreSettings[obj._id][_attr].replace(/"/g, '\\"');
            }
        }
    } else if (webPreSettings[obj._id]) {
        delete webPreSettings[obj._id];
    }
}

function getExtensionsAndSettings(callback) {
    adapter.getObjectView('system', 'instance', null, (err, doc) => {
        if (err) {
            callback && callback(err, []);
        } else {
            if (doc.rows.length === 0) {
                callback && callback(null, []);
            } else {
                const res = [];
                for (let i = 0; i < doc.rows.length; i++) {
                    const instance = doc.rows[i].value;
                    if (instance && instance.common) {
                        if ((adapter.config.startDisabledExtensions || instance.common.enabled) &&
                            instance.common.webExtension &&
                        (instance.native.webInstance === adapter.namespace || instance.native.webInstance === '*')) {

                            // decrypt all native attributes listed in instance.encryptedNative
                            if (Array.isArray(instance.encryptedNative) && instance.native) {
                                instance.encryptedNative.forEach(key => {
                                    if (instance.native[key]) {
                                        instance.native[key] = adapter.decrypt(secret, instance.native[key]);
                                    }
                                });
                            }

                            res.push(instance);
                        }
                        if (instance.common.webPreSettings) {
                            updatePreSettings(instance);
                        }
                        if (instance.common.webByVersion) {
                            // 'system.adapter.'.length = 15
                            const _id = doc.rows[i].value._id.substring(15).replace(/\.\d+$/, '');
                            webByVersion[_id] = instance.common.version;
                        }
                    }
                }
                callback && callback(null, res);
            }
        }
    });
}

function main() {
    getExtensionsAndSettings(async (err, ext) => {
        err && adapter.log.error(`Cannot read extensions: ${err}`);
        if (ext) {
            for (let e = 0; e < ext.length; e++) {
                if (ext[e] && ext[e].common) {
                    const instance = ext[e]._id.substring('system.adapter.'.length);
                    const name = instance.split('.')[0];

                    extensions[instance] = {
                        path: `${name}/${ext[e].common.webExtension}`,
                        config: ext[e]
                    };
                }
            }
        }
        if (adapter.config.userListSettings) {
            try {
                const _users = await adapter.getObjectViewAsync('system', 'user', {startkey: 'system.user.', endkey: 'system.user.\u9999'});
                users = {};
                for (let u = 0; u < _users.rows.length; u++) {
                    users[_users.rows[u].value._id] = _users.rows[u].value;
                }
            } catch (e) {
                adapter.log.error(`Cannot read users: ${e}`);
            }
            try {
                const _groups = await adapter.getObjectViewAsync('system', 'group', {startkey: 'system.group.', endkey: 'system.group.\u9999'});
                groups = {};
                for (let u = 0; u < _groups.rows.length; u++) {
                    groups[_groups.rows[u].value._id] = _groups.rows[u].value;
                }
            } catch (e) {
                adapter.log.error(`Cannot read users: ${e}`);
            }
            await adapter.subscribeForeignObjectsAsync('system.user.*');
            await adapter.subscribeForeignObjectsAsync('system.group.*');
        }

        // TODO: This whole setting of webServer global is pretty nasty, needs cleaning up.
        initWebServer(adapter.config)
            .then(returnedServer => webServer = returnedServer)
            .catch(err => {
                adapter.log.error(`Failed to initWebServer: ${err}`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            });
        // monitor extensions and pro keys
        adapter.subscribeForeignObjects('system.adapter.*');
    });
}

/* function readDirs(dirs, cb, result) {
    result = result || [];
    if (!dirs || !dirs.length) {
        return cb && cb(result);
    }
    const dir = dirs.shift();
    adapter.readDir(dir, '', (err, files) => {
        if (!err && files && files.length) {
            for (let f = 0; f < files.length; f++) {
                if (files[f].file.match(/\.html$/)) {
                    result.push(dir + '/' + files[f].file);
                }
            }
        }
        setImmediate(readDirs, dirs, cb, result);
    });
}
*/
let indexHtml;

function getLinkVar(_var, obj, attr, link) {
    if (attr === 'protocol') {
        attr = 'secure';
    }

    if (_var === 'ip') {
        link = link.replace(`%${_var}%`, '$host$');
    } else if (_var === 'instance') {
        const instance = obj._id.split('.').pop();
        link = link.replace(`%${_var}%`, instance);
    } else {
        if (obj) {
            if (attr.startsWith('native_')) {
                attr = attr.substring(7);
            }

            let val = obj.native[attr];
            if (_var === 'bind' && (!val || val === '0.0.0.0')) {
                val = '$host$';
            }

            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, val ? 'https' : 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, val);
                } else {
                    link = link.replace(`%${_var}%`, val);
                }
            }
        } else {
            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, '');
                } else {
                    link = link.replace(`%${_var}%`, '');
                }
            }
        }
    }

    return link;
}

function resolveLink(link, instanceObj, instancesMap) {
    const vars = link.match(/%(\w+)%/g);
    let _var;
    let v;
    let parts;
    let result;

    if (vars) {
        // first replace simple patterns
        for (v = vars.length - 1; v >= 0; v--) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            parts = _var.split('_');
            // like "port"
            if (_var.startsWith('native_')) {
                link = getLinkVar(_var, instanceObj, _var, link);
                vars.splice(v, 1);
            } else if (parts.length === 1) {
                link = getLinkVar(_var, instanceObj, parts[0], link);
                vars.splice(v, 1);
            } else if (parts[0].match(/\.\d+$/)) {
                // like "web.0_port"
                link = getLinkVar(_var, instancesMap[`system.adapter.${parts[0]}`], parts[1], link);
                vars.splice(v, 1);
            }
        }

        const links = {};
        let instances;
        const adptr = parts[0];
        // process web_port
        for (v = 0; v < vars.length; v++) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            if (_var.startsWith('native_')) {
                _var = _var.substring(7);
            }

            parts = _var.split('_');
            if (!instances) {
                instances = [];
                // TODO !
                /*for (let inst = 0; inst < 10; inst++) {
                    if (that.main.objects[`system.adapter.${adptr}.${inst}`]) {
                        instances.push(inst);
                    }
                }*/
            }

            for (let i = 0; i < instances.length; i++) {
                links[adptr + '.' + i] = {
                    instance: `${adptr}.${i}`,
                    link: getLinkVar(_var, instancesMap[`system.adapter.${adptr}.${i}`], parts[1], links[`${adptr}.${i}`] ? links[adptr + '.' + i].link : link)
                };
            }
        }
        if (instances) {
            result = [];
            let count = 0;
            let firstLink = '';
            for (const d of Object.keys(links)) {
                result[links[d].instance] = links[d].link;
                firstLink = firstLink || links[d].link;
                count++;
            }
            if (count < 2) {
                link = firstLink;
                result = null;
            }
        }
    }
    return result || link;
}

/*function replaceInLink(link, instanceObj, instances) {
    if (typeof link === 'object') {
        const links = JSON.parse(JSON.stringify(link));
        let first = '';
        for (const v of Object.keys(links)) {
            links[v] = resolveLink(links[v], instanceObj, instances);
            first = first || links[v];
        }
        links.__first = first;
        return links;
    } else {
        return resolveLink(link, instanceObj, instances);
    }
}*/

function processWelcome(welcomeScreen, isPro, adapterObj, foundInstanceIDs, list) {
    if (welcomeScreen) {
        welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
        if (Array.isArray(welcomeScreen)) {
            for (let w = 0; w < welcomeScreen.length; w++) {
                // temporarily disabled for non-pro
                if (!isPro && welcomeScreen[w].name === 'vis editor') {
                    continue;
                }
                if (welcomeScreen[w].localLinks && typeof welcomeScreen[w].localLinks === 'string') {
                    welcomeScreen[w].localLink = adapterObj.common.localLinks[welcomeScreen[w].localLinks];
                    if (typeof welcomeScreen[w].localLink === 'object') {
                        welcomeScreen[w].localLink = welcomeScreen[w].localLink.link;
                    }
                } else if (welcomeScreen[w].localLink && typeof welcomeScreen[w].localLink === 'boolean') {
                    welcomeScreen[w].localLink = adapterObj.common.localLink;
                }

                welcomeScreen[w].pro = isPro;
                if (welcomeScreen[w].localLink) {
                    if (foundInstanceIDs.length > 1) {
                        foundInstanceIDs.forEach(id => {
                            const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen[w]));
                            _welcomeScreen.id = id;
                            _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                            list.push(_welcomeScreen);
                        });
                    } else {
                        welcomeScreen[w].id = foundInstanceIDs[0];
                        list.push(welcomeScreen[w]);
                    }
                } else {
                    list.push(welcomeScreen[w]);
                }
            }
        } else {
            if (welcomeScreen.localLinks && typeof welcomeScreen.localLinks === 'string') {
                welcomeScreen.localLink = adapterObj.common.localLinks[welcomeScreen.localLinks];
                if (typeof welcomeScreen.localLink === 'object') {
                    welcomeScreen.localLink = welcomeScreen.localLink.link;
                }
            } else if (welcomeScreen.localLink && typeof welcomeScreen.localLink === 'boolean') {
                welcomeScreen.localLink = adapterObj.common.localLink;
            }
            welcomeScreen.pro = isPro;
            if (welcomeScreen.localLink) {
                if (foundInstanceIDs.length > 1) {
                    foundInstanceIDs.forEach(id => {
                        const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                        _welcomeScreen.id = id;
                        _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                        list.push(_welcomeScreen);
                    });
                } else {
                    welcomeScreen.id = foundInstanceIDs[0];
                    list.push(welcomeScreen);
                }
            } else {
                list.push(welcomeScreen);
            }
        }
    }
}

async function getListOfAllAdapters(settings, server, req) {
    // read all instances
    const instances = await adapter.getObjectViewAsync('system', 'instance', {});
    const adapters = await adapter.getObjectViewAsync('system', 'adapter', {});
    const list = [];
    const mapInstance = {};
    for (let r = 0; r < instances.rows.length; r++) {
        mapInstance[instances.rows[r].id] = instances.rows[r].value;
    }
    for (let a = 0; a < adapters.rows.length; a++) {
        const obj = adapters.rows[a].value;
        let found;
        if (instances && instances.rows) {
            found = [];
            // find if any instance of this adapter exists and started
            for (let i = 0; i < instances.rows.length; i++) {
                let id = instances.rows[i].id;
                const ids = id.split('.');
                ids.pop();
                id = ids.join('.');
                if (id === obj._id &&
                    instances.rows[i].value.common
                    // && (true || instances.rows[i].value.common.enabled || instances.rows[i].value.common.onlyWWW)
                ) {
                    found.push(instances.rows[i].id);
                }
            }
        }

        if (found && found.length) {
            try {
                processWelcome(obj.common.welcomeScreen, false, obj, found, list);
                processWelcome(obj.common.welcomeScreenPro, true, obj, found, list);
            } catch (e) {
                adapter.log.warn(`Cannot process welcome screen for "${obj._id}": ${e}`);
            }
        }
    }

    if (!indexHtml && !fs.existsSync(`${__dirname}/${wwwDir}/index.html`)) {
        return `${__dirname}/${wwwDir}/index.html was not found or no access! Check the file or access rights or start the fixer: "curl -sL https://iobroker.net/fix.sh | bash -"`;
    }

    indexHtml = indexHtml || fs.readFileSync(`${__dirname}/${wwwDir}/index.html`).toString();

    // calculate localLinks
    for (let t = 0; t < list.length; t++) {
        if (list[t].localLink) {
            list[t].localLink = resolveLink(list[t].localLink, mapInstance[list[t].id], mapInstance);
        }
        if (!list[t].name) {
            list[t].name = list[t].title;
        }
    }

    // try to find swagger web-extension
    // inform extensions
    Object.keys(extensions).forEach(instance => {
        try {
            if (extensions?.[instance]?.obj?.welcomePage && typeof extensions[instance].obj.welcomePage === 'function') {
                list.push(extensions[instance].obj.welcomePage());
            }
        } catch (err) {
            adapter.log.error(`Cannot call welcomePage for "${instance}": ${err.message}`);
        }
    });

    list.sort((a, b) => {
        const aName = (typeof a.name === 'object' ? a.name[lang] || a.name.en : a.name).toLowerCase();
        const bName = (typeof b.name === 'object' ? b.name[lang] || b.name.en : b.name).toLowerCase();
        if (a.order === undefined && b.order === undefined) {
            if (aName > bName) {
                return 1;
            }
            if (aName < bName) {
                return -1;
            }
            return 0;
        } else if (a.order === undefined) {
            return -1;
        } else if (b.order === undefined) {
            return 1;
        } else {
            if (a.order > b.order) {
                return 1;
            }
            if (a.order < b.order) {
                return -1;
            }
            if (aName > bName) {
                return 1;
            }
            if (aName < bName) {
                return -1;
            }
            if (a.instance !== undefined && b.instance !== undefined) {
                if (a.instance > b.instance) {
                    return 1;
                }
                if (a.instance < b.instance) {
                    return -1;
                }
            }

            return 0;
        }
    });

    let text = `systemLang = "${lang}";\n`;
    text += `list = ${JSON.stringify(list, null, 2)};\n`;

    const whiteListIp = isInWhiteList(settings, server, req);

    // if login
    text += `let authEnabled = ${adapter.config.auth && !adapter.config.basicAuth && !whiteListIp};\n`;

    return indexHtml.replace('// -- PLACE THE LIST HERE --', text);
}

function getInfoJs(settings) {
    const result = [
        `var socketUrl = "${socketUrl}";`,
        `var socketSession = "";`,
        `window._authIoBroker = ${settings.auth};`,
        `window.sysLang = "${lang}";`,
        `window.socketForceWebSockets = ${settings.forceWebSockets ? 'true' : 'false'};`
    ];
    for (const id of Object.keys(webPreSettings)) {
        if (webPreSettings[id]) {
            for (const attr of Object.keys(webPreSettings[id])) {
                result.push(`window.${attr} = "${webPreSettings[id][attr]}";`);
            }
        }
    }
    return result.join(' ');
}

function prepareLoginTemplate() {
    let def =
        '            font: 13px/20px \'Lucida Grande\', Tahoma, Verdana, sans-serif;\n' +
        '            color: #404040;\n' +
        '            background-color: #0ae;\n' +
        '            background-image: -webkit-gradient(linear, 0 0, 0 100%, color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.5, transparent), to(transparent));\n' +
        '            background-image: -webkit-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -moz-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -ms-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -o-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-size: 50px 50px;\n'
    ;
    const template = fs.readFileSync(`${__dirname}/${wwwDir}${LOGIN_PAGE}`).toString('utf8');
    if (adapter.config.loginBackgroundColor) {
        def = `background-color: ${adapter.config.loginBackgroundColor};\n`;
    }
    if (adapter.config.loginBackgroundImage) {
        def += `            background-image: url(../${adapter.namespace}/login-bg.png);\n`;
    }
    return template.replace('background: black;', def);
}

function checkUser(username, password, cb) {
    username = (username || '').toString().replace(FORBIDDEN_CHARS, '_').replace(/\s/g, '_').replace(/\./g, '_').toLowerCase();

    if (bruteForce[username] && bruteForce[username].errors > 4) {
        let minutes = Date.now() - bruteForce[username].time;
        if (bruteForce[username].errors < 7) {
            if (Date.now() - bruteForce[username].time < 60000) {
                minutes = 1;
            } else {
                minutes = 0;
            }
        } else if (bruteForce[username].errors < 10) {
            if (Date.now() - bruteForce[username].time < 180000) {
                minutes = Math.ceil((180000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else if (bruteForce[username].errors < 15) {
            if (Date.now() - bruteForce[username].time < 600000) {
                minutes = Math.ceil((600000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else if (Date.now() - bruteForce[username].time < 3600000) {
            minutes = Math.ceil((3600000 - minutes) / 60000);
        } else {
            minutes = 0;
        }

        if (minutes) {
            return cb(`Too many errors. Try again in ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}.`, false);
        }
    }

    adapter.checkPassword(username, password, res => {
        if (!res) {
            bruteForce[username] = bruteForce[username] || {errors: 0};
            bruteForce[username].time = Date.now();
            bruteForce[username].errors++;
        } else if (bruteForce[username]) {
            delete bruteForce[username];
        }

        if (res) {
            return cb(null, username);
        } else {
            return cb(null, false);
        }
    });
}

function initAuth(server, settings) {
    session       = require('express-session');
    cookieParser  = require('cookie-parser');
    bodyParser    = require('body-parser');
    AdapterStore  = utils.commonTools.session(session, settings.ttl);
    passport      = require('passport');
    LocalStrategy = require('passport-local').Strategy;
    flash         = require('connect-flash'); // TODO report error to user

    store = new AdapterStore({adapter});

    passport.use(new LocalStrategy(checkUser));

    passport.serializeUser((user, done) => done(null, user));

    passport.deserializeUser((user, done) => done(null, user));

    server.app.use(cookieParser());
    server.app.use(bodyParser.urlencoded({extended: true}));
    server.app.use(bodyParser.json());
    server.app.use(bodyParser.text());
    server.app.use(session({
        secret,
        saveUninitialized: true,
        resave:            true,
        cookie:            {maxAge: settings.ttl * 1000, httpOnly: false}, // default TTL
        store
    }));
    server.app.use(passport.initialize());
    server.app.use(passport.session());
    server.app.use(flash());
}

/**
 * Send response to a byte ranges request
 *
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {Buffer} buffer - buffer to be sent
 * @returns {void}
 */
function sendRange(req, res, buffer) {
    /** @type {Record<string, number>[]} */
    const ranges = req.range(buffer.length);

    if (ranges.length > 1) {
        adapter.log.warn('Multiple ranges currently not supported, sending whole buffer');
        res.status(200).send(buffer);
        return;
    }

    // This is for <video> tag on iOS Safari, only one range is used by Safari, so this is enough for now
    const range = ranges[0] || {start: 0, end: buffer.length};
    res.set('Content-Range', `bytes ${range.start}-${range.end}/${buffer.length}`);
    const buf = buffer.slice(range.start, range.end + 1);
    res.set('Content-Length', buf.length);
    res.status(206).send(buf);
}

function getSocketIoFile(req, res, next) {
    if (next === true || req.url.endsWith('socket.io.js') || req.url.match(/\/socket\.io\.js(\?.*)?$/)) {
        if (socketIoFile) {
            res.contentType('text/javascript');
            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
            return res.status(200).send(socketIoFile);
        } else {
            // if used internal socket io, so deliver @iobroker/ws
            if ((!adapter.config.socketio && adapter.config.usePureWebSockets) || adapter.config.socketio.startsWith('system.adapter.ws.')) {
                let file;
                // If debug version stored
                if (fs.existsSync(`${__dirname}/www/lib/js/ws.js`)) {
                    file =`${__dirname}/www/lib/js/ws.js`;
                } else {
                    const pathToFile = require.resolve(`${utils.appName}.ws`);
                    file = path.join(path.dirname(pathToFile), '/lib/socket.io.js');
                }
                socketIoFile = fs.readFileSync(file);
            } else {
                // try to get file from iobroker.socketio adapter
                let file;
                try {
                    const dir = require.resolve(`${utils.appName}.socketio`);
                    file = path.join(path.dirname(dir), '/lib/socket.io.js');
                } catch (e) {
                    // ignore
                }

                if (file && fs.existsSync(file)) {
                    socketIoFile = fs.readFileSync(file);
                } else {
                    try {
                        // try to get socket.io-client
                        const dir = require.resolve('socket.io-client');
                        const fileDir = path.join(path.dirname(dir), '../dist/');
                        if (fs.existsSync(`${fileDir}socket.io.min.js`)) {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.min.js`);
                        } else {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.js`);
                        }
                    } catch (e) {
                        try {
                            // if nothing works, read stored in web file
                            socketIoFile = fs.readFileSync(`${__dirname}/${wwwDir}/lib/js/socket.io.js`);
                        } catch (e) {
                            adapter.log.error(`Cannot read socket.io.js: ${e}`);
                            socketIoFile = false;
                        }
                    }
                }
            }

            if (socketIoFile) {
                res.contentType('text/javascript');
                res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                return res.status(200).send(socketIoFile);
            } else {
                socketIoFile = false;
                return res.status(404).end();
            }
        }
    } else {
        next();
    }
}

function getRedirectPage(req) {
    let redirect = '../';
    let parts;
    req.body = req.body || {};
    // const isDev = req.url.includes('?dev&');

    const origin = req.body.origin || '?href=%2F';

    if (origin) {
        parts = origin.split('=');
        if (parts.length > 1 && parts[1]) {
            redirect = decodeURIComponent(parts[1]);
            // if some invalid characters in redirect
            if (redirect.match(/[^-_a-zA-Z0-9&%?./]/)) {
                redirect = '../';
            }
        }
    }

    return redirect;
}

function isInWhiteList(settings, server, req) {
    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    if (!adapter.config.auth) {
        return remoteIp;
    } else if (settings.whiteListSettings) {
        // if whitelist is used
        let whiteListIp = server.io && server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
        if (!whiteListIp && server.io && remoteIp === '::1') {
            whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
        }

        if (whiteListIp && settings.whiteListSettings[whiteListIp].user !== 'auth') {
            adapter.log.silly(`whiteListIp ${whiteListIp}`);
            return whiteListIp;
        } else {
            adapter.log.debug(`Request from "${remoteIp}". Must authenticate, as IP not found in the white list`);
        }
    }

    return '';
}

async function getFoldersOfObject(path) {
    try {
        const projects = await adapter.readDirAsync(path || 'vis.0', '');
        return projects.filter(dir => dir.isDir).map(dir => dir.file);
    } catch (e) {
        adapter.log.warn(`Cannot read "${path || 'vis.0'}" directory: ${e}`);
    }

    return [];
}

async function processReadFolders(settings, req, res) {
    const params = req.url.split('?')[1];
    const query = {};
    if (params) {
        const parts = params.split('&');
        for (let p = 0; p < parts.length; p++) {
            const parts2 = parts[p].split('=');
            query[decodeURIComponent(parts2[0])] = parts2[1] === undefined ? true : decodeURIComponent(parts2[1]);
            if (query[parts2[0]] === 'true') {
                query[parts2[0]] = true;
            } else if (query[parts2[0]] === 'false') {
                query[parts2[0]] = false;
            }
        }
    }

    if (settings.auth) {
        // with basic authentication
        if (req.headers.authorization && req.headers.authorization.startsWith('Basic ')) {
            const [user, pass] = Buffer.from(req.headers.authorization.split(' ')[1], 'base64').toString().split(':');
            checkUser(user, pass, async (err, user) => {
                if (user) {
                    const list = await getFoldersOfObject(query.adapter);
                    res.json({result: list});
                } else {
                    res.status(401).json({error: 'Unauthorized'});
                }
            });
        } else {
            res.status(401).json({error: 'Unauthorized'});
        }
    } else {
        const list = await getFoldersOfObject(query.adapter);
        res.json({result: list});
    }
}

//settings: {
//    "port":   8080,
//    "auth":   false,
//    "secure": false,
//    "bind":   "0.0.0.0", // "::"
//    "cache":  false
//}
async function initWebServer(settings) {
    const server = {
        app:    null,
        server: null,
        io:     null,
        settings
    };
    adapter.subscribeForeignObjects('system.config');

    settings.ttl = parseInt(settings.ttl, 10) || 3600;

    if (settings.ttl < 30) {
        settings.ttl = 30;
    }

    if (!settings.whiteListEnabled && settings.whiteListSettings) {
        delete settings.whiteListSettings;
    }

    settings.defaultUser = settings.defaultUser || 'system.user.admin';
    if (!settings.defaultUser.startsWith('system.user.')) {
        settings.defaultUser = `system.user.${settings.defaultUser}`;
    }

    if (settings.port) {
        server.app = express();
        server.app.use(compression());

        server.app.disable('x-powered-by');
        // enable use of i-frames together with HTTPS
        // todo find the admin port and bind and use it here "ALLOW-FROM ipbind:port"
        // try to add "Content-Security-Policy: frame-ancestors 'self' example.com *.example.net ;"
        /*
        server.app.get('/*', (req, res, next) => {
            res.header('X-Frame-Options' , 'SAMEORIGIN');
            next(); // http://expressjs.com/guide.html#passing-route control
        });
        */

        // replace socket.io
        server.app.use((req, res, next) => getSocketIoFile(req, res, next));

        // special end point for vis
        server.app.get('/visProjects', async (req, res) => await processReadFolders(settings, req, res));
        server.app.get('/folders', async (req, res) => await processReadFolders(settings, req, res));

        if (settings.auth) {
            initAuth(server, settings);

            /**
             * Authenticates at the server with the given username and password provided in req
             *
             * @param {object} req - request object having properties username and password
             * @param {object} res - response object
             * @param {function} next - express next function
             * @param {string} redirect - redirect path
             * @param {string} origin - origin path
             */
            const authenticate = (req, res, next, redirect, origin) => {
                passport.authenticate('local', (err, user) => {
                    // replace user
                    if (user && settings.userListEnabled) {
                        // get the user group
                        const longUser = user.startsWith('system.user.') ? user : `system.user.${user}`;
                        user = '';
                        if (settings.userListSettings.users.includes(longUser)) {
                            if (settings.userListSettings.accessAsUser) {
                                user = settings.userListSettings.accessAsUser;
                            } else {
                                user = longUser;
                            }
                        } else {
                            const groupId = Object.keys(groups).find(groupId => groups[groupId].common.members.includes(longUser));
                            if (settings.userListSettings.groups.includes(groupId)) {
                                if (settings.userListSettings.accessAsUser) {
                                    user = settings.userListSettings.accessAsUser;
                                } else {
                                    user = longUser;
                                }
                            }
                        }
                        if (!user) {
                            adapter.log.warn(`User ${longUser} is not in the user list`);
                        } else {
                            adapter.log.debug(`User ${longUser} threaded as ${user}`);
                            user = user.substring('system.user.'.length);
                        }
                    }

                    if (req.url.includes('/loginApp')) {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.status(401).json({error: 'cannot login user'});
                        }
                        if (!user) {
                            adapter.log.warn('User not found');
                            return res.status(401).json({error: 'cannot login user'});
                        }
                    } else {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                        if (!user) {
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                    }

                    req.logIn(user, err => {
                        if (req.url.includes('/loginApp')) {
                            if (err) {
                                adapter.log.warn(`Cannot login user: ${err}`);
                                return res.status(401).json({error: 'cannot login user'});
                            }
                        } else {
                            if (err) {
                                adapter.log.warn(`Cannot login user: ${err}`);
                                return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                            }
                        }
                        if (req.body.stayLoggedIn) {
                            req.session.cookie.maxAge = settings.ttl > ONE_MONTH_SEC ? settings.ttl * 1000 : ONE_MONTH_SEC * 1000;
                        } else {
                            req.session.cookie.maxAge = settings.ttl * 1000;
                        }
                        if (req.url.includes('/loginApp')) {
                            res.json({ result: 'ok', user });
                        } else {
                            return res.redirect(redirect);
                        }
                    });
                })(req, res, next);
            };

            /**
             * Auto Logon if possible else it will redirect or return Basic Auth information if activated
             *
             * @param {Request} req - request object
             * @param {Response} res - response object
             * @param {function} next - next function of express
             * @param {string} redirect - redirect path
             * @returns {void|*|Response}
             */
            const autoLogonOrRedirectToLogin = (req, res, next, redirect) => {
                let isJs;
                if (/\.css(\?.*)?$/.test(req.originalUrl)) {
                    res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                    return res.status(200).send('');
                } else if ((isJs = /\.js(\?.*)?$/.test(req.originalUrl))) {
                    // return always valid js file for js, because if cache is active it leads to errors
                    const parts = req.originalUrl.split('/');
                    parts.shift();

                    // if request for web/lib, ignore it, because no redirect information
                    if (parts[0] === 'lib') {
                        res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                        return res.status(200).send('');
                    }
                }

                const whiteListIp = isInWhiteList(settings, server, req);

                // if not authenticated
                if (!whiteListIp) {
                    if (isJs) {
                        return res.status(200).send(`document.location="${LOGIN_PAGE}?href=" + encodeURI(location.href.replace(location.origin, ""));`);
                    } else if (adapter.config.basicAuth) {
                        // if basic auth active, we tell it by sending a header with status 401
                        res.set('WWW-Authenticate', `Basic realm="Access to ioBroker web", charset="UTF-8"`);
                        return res.status(401).send('Basic Authentication has been aborted. You have to reload the page.');
                    } else {
                        return res.redirect(redirect);
                    }
                }

                req.logIn(settings.whiteListSettings[whiteListIp].user, err => next(err));
            };

            server.app.post('/login', (req, res, next) => {
                let redirect = getRedirectPage(req);

                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                if (req.body.username && settings.addUserName && !redirect.includes('?')) {
                    const parts = redirect.split('#');
                    parts[0] += `?${req.body.username}`;
                    redirect = parts.join('#');
                }

                authenticate(req, res, next, redirect, req.body.origin || '?href=%2F');
            });

            // Login for applications to preserve cookie
            server.app.post('/loginApp', (req, res, next) => {
                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                authenticate(req, res, next, '', req.body.origin || '?href=%2F');
            });

            server.app.get('/logout', (req, res) => {
                const isDev = req.url.includes('?dev');
                req.logout(() => {
                    if (isDev) {
                        res.redirect('http://localhost:3000/index.html?login');
                    } else {
                        res.redirect(LOGIN_PAGE);
                    }
                });
            });

            // route middleware to make sure a user is logged in
            server.app.use((req, res, next) => {
                // return favicon always
                if (req.originalUrl.endsWith('favicon.ico')) {
                    res.set('Content-Type', 'image/x-icon');
                    return res.send(fs.readFileSync(`${__dirname}/${wwwDir}/login/favicon.ico`));
                }
                // if cache.manifest got back not 200 it makes an error
                if (req.isAuthenticated() ||
                    /web\.\d+\/login-bg\.png(\?.*)?$/.test(req.originalUrl) ||
                    /cache\.manifest(\?.*)?$/.test(req.originalUrl) ||
                    /^\/login\//.test(req.originalUrl) ||
                    /\.ico(\?.*)?$/.test(req.originalUrl)
                ) {
                    return next();
                } else if (adapter.config.basicAuth && typeof req.headers.authorization === 'string' && req.headers.authorization.startsWith('Basic')) {
                    // not logged in yet, and basic auth is active + header present
                    const b64auth = req.headers.authorization.split(' ')[1];
                    const [login, password] = Buffer.from(b64auth, 'base64').toString().split(':');

                    req.body = req.body || {};

                    req.body.username = login;
                    req.body.password = password;
                    req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                    const origin = req.body.origin || '?href=%2F';
                    const redirect = req.originalUrl;

                    authenticate(req, res, next, redirect, origin);
                } else {
                    // not logged in yet, redirect, auto login or send 401 if basicAuth activated
                    autoLogonOrRedirectToLogin(req, res, next, `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`);
                }
            });

            // get user by session  /cookie
            server.app.get('/getUser', (req, res, next) => {
                if (req.isAuthenticated()) {
                    const parts = req.headers.cookie.split(';');
                    const cookie = {};
                    parts.forEach(item => {
                        const [name, value] = item.split('=');
                        cookie[name.trim()] = value;
                    });

                    if (cookie['connect.sid']) {
                        store && store.get(req.session.id, (err, obj) => {
                            // obj = {"cookie":{"originalMaxAge":2592000000,"expires":"2020-09-24T18:09:50.377Z","httpOnly":true,"path":"/"},"passport":{"user":"admin"}}
                            if (obj) {
                                res.send({ expires: obj.cookie.expires, user: obj.passport.user });
                            } else {
                                res.status(501).send('User not logged in.');
                            }
                        });
                    } else {
                        res.status(501).send('User not logged in.');
                    }
                } else {
                    res.status(501).send('User not logged in.');
                }
            });
            
            // todo
            server.app.get('/prolongSession', (req, res, next) => {
                if (req.isAuthenticated()) {
                    req.session.touch();
                    const parts = req.headers.cookie.split(';');
                    const cookie = {};
                    parts.forEach(item => {
                        const [name, value] = item.split('=');
                        cookie[name.trim()] = value;
                    });

                    if (cookie['connect.sid']) {
                        store && store.get(req.session.id, (err, obj) => {
                            // obj = {"cookie":{"originalMaxAge":2592000000,"expires":"2020-09-24T18:09:50.377Z","httpOnly":true,"path":"/"},"passport":{"user":"admin"}}
                            if (obj) {
                                const expires = new Date();
                                //expires.setMilliseconds(expires.getMilliseconds() + req.session.cookie.maxAge);

                                obj.cookie.expires = expires.toISOString();
                                console.log(`Session ${req.session.id} expires on ${obj.cookie.expires}`);

                                store.set(req.session.id, obj);
                                //res.cookie('connect.sid', cookie['connect.sid'], { maxAge: req.session.cookie.maxAge, httpOnly: true });
                                res.send({ expires: obj.cookie.expires, user: obj.passport.user });
                            } else {
                                res.status(501).send('cannot prolong');
                            }
                        });
                    } else {
                        res.status(501).send('cannot prolong');
                    }
                } else {
                    autoLogonOrRedirectToLogin(req, res, next, `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`);
                }
            });
        } else {
            server.app.get('/iobroker_check.html', (req, res) => res.send('ioBroker.web'));
            server.app.get('/login', (req, res) => res.redirect('/'));
            server.app.get('/logout', (req, res) => res.redirect('/'));

            if (settings.whiteListEnabled) {
                initAuth(server, settings);
                server.app.use((req, res, next) => {
                    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
                    let whiteListIp = server.io && server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
                    if (!whiteListIp && server.io && remoteIp === '::1') {
                        whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
                    }
                    adapter.log.silly(`whiteListIp ${whiteListIp}`);
                    if (whiteListIp) {
                        req.logIn(settings.whiteListSettings[whiteListIp].user, err =>
                            next(err));
                    } else {
                        req.logIn(settings.defaultUser.substr(12), err => // cut "system.user."
                            next(err));
                    }
                });
            }
        }

        if (!settings.disableStates) {
            adapter.log.debug('Activating states & socket info');
            // Init read from states
            server.app.get('/state/*', (req, res) => {
                try {
                    const fileName = req.url.split('/', 3)[2].split('?', 2);
                    adapter.getForeignObject(fileName[0], (err, obj) => {
                        let contentType = 'text/plain';
                        if (obj && obj.common.type === 'file')  {
                            contentType = mime.lookup(fileName[0]);
                        }
                        if (obj && obj.common.type === 'file') {
                            const getForeignBinaryState = adapter.getForeignBinaryState || adapter.getBinaryState;
                            getForeignBinaryState.call(adapter, fileName[0], {user: req.user ? `system.user.${req.user}` : settings.defaultUser}, (err, obj) => {
                                if (!err && obj !== null && obj !== undefined) {
                                    if (obj && typeof obj === 'object' && obj.val !== undefined && obj.ack !== undefined) {
                                        res.set('Content-Type', 'application/json');
                                    } else {
                                        res.set('Content-Type', contentType || 'text/plain');
                                    }
                                    res.set('Cache-Control', 'no-cache');
                                    res.status(200).send(obj);
                                } else {
                                    res.status(404).send(`404 Not found. File ${escapeHtml(fileName[0])} not found`);
                                }
                            });
                        } else {
                            adapter.getForeignState(fileName[0], {user: req.user ? `system.user.${req.user}` : settings.defaultUser}, (err, obj) => {
                                if (!err && obj !== null && obj !== undefined) {
                                    res.set('Content-Type', 'text/plain');
                                    res.set('Cache-Control', 'no-cache');
                                    if (fileName[1] && fileName[1].includes('json')) {
                                        res.status(200).send(JSON.stringify(obj));
                                    } else {
                                        res.status(200).send(obj.val === undefined ? 'undefined' :
                                            (obj.val === null ? 'null' :
                                                (typeof obj.val === 'object' ? JSON.stringify(obj.val) : obj.val.toString())));
                                    }
                                } else {
                                    res.status(404).send(`404 Not found. File ${escapeHtml(fileName[0])} not found`);
                                }
                            });
                        }
                    });
                } catch (e) {
                    res.status(500).send(`500. Error${e}`);
                }
            });
        }

        server.app.get('*/_socket/info.js', (req, res) => {
            res.set('Content-Type', 'application/javascript');
            res.set('Cache-Control', 'no-cache');
            res.status(200).send(getInfoJs(settings));
        });

        // Enable CORS
        if (settings.socketio || adapter.common.loglevel === 'debug') {
            server.app.use((req, res, next) => {
                res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
                res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
                res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With, *');
                res.header('Access-Control-Allow-Credentials', 'true');

                // intercept OPTIONS method
                if ('OPTIONS' === req.method) {
                    res.status(200).send(200);
                } else {
                    next();
                }
            });
        }

        const appOptions = {};
        if (settings.cache) {
            appOptions.maxAge = 30758400000; // one year
        }

        try {
            const webserver = new IoBWebServer.WebServer({app: server.app, adapter, secure: settings.secure});
            server.server = await webserver.init();
        } catch (err) {
            adapter.log.error(`Cannot create web-server: ${err}`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }
        if (!server.server) {
            adapter.log.error(`Cannot create web-server`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }

        server.server.__server = server;
    } else {
        adapter.log.error('port missing');
        adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    }

    if (server.server) {
        let serverListening = false;
        let serverPort;
        server.server.on('error', e => {
            if (e.toString().includes('EACCES') && serverPort <= 1024) {
                adapter.log.error(`node.js process has no rights to start server on the port ${serverPort}.\n` +
                    `Do you know that on linux you need special permissions for ports under 1024?\n` +
                    `You can call in shell following scrip to allow it for node.js: "iobroker fix"`
                );
            } else {
                adapter.log.error(`Cannot start server on ${settings.bind || '0.0.0.0'}:${serverPort}: ${e}`);
            }
            if (!serverListening) {
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
        });

        settings.port = parseInt(settings.port, 10) || 8082;
        serverPort = settings.port;

        adapter.getPort(settings.port, (!settings.bind || settings.bind === '0.0.0.0') ? undefined : settings.bind || undefined, port => {
            port = parseInt(port, 10);
            if (port !== settings.port && !settings.findNextPort) {
                adapter.log.error(`port ${settings.port} already in use`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
            serverPort = port;
            server.server.listen(port, (!settings.bind || settings.bind === '0.0.0.0') ? undefined : settings.bind || undefined, () => {
                serverListening = true;
                adapter.setState('info.connection', true, true);

                if (!settings.doNotCheckPublicIP && !settings.auth) {
                    checkTimeout = adapter.setTimeout(async () => {
                        checkTimeout = null;
                        try {
                            await IoBWebServer.checkPublicIP(settings.port, 'ioBroker.web', '/iobroker_check.html');
                        } catch (e) {
                            // this supported first from js-controller 5.0.
                            adapter.sendToHost(
                                `system.host.${adapter.host}`,
                                'addNotification',
                                {
                                    scope: 'system',
                                    category: 'securityIssues',
                                    message:
                                        'Your web instance is accessible from the internet without any protection. ' +
                                        'Please enable authentication or disable the access from the internet.',
                                    instance: `system.adapter.${adapter.namespace}`
                                },
                                (/* result */) => {
                                    /* ignore */
                                }
                            );

                            adapter.log.error(e.toString());
                        }
                    }, 1000);
                }
            });

            adapter.log.info(`http${settings.secure ? 's' : ''} server listening on port ${port}`);
        });
    }

    // Activate integrated socket
    if (ownSocket) {
        adapter.log.debug('Activating IOSocket');
        const socketSettings = JSON.parse(JSON.stringify(settings));
        // Authentication checked by server itself
        socketSettings.auth = settings.auth;
        socketSettings.secret = secret;
        socketSettings.store = store;
        socketSettings.ttl = settings.ttl || 3600;
        socketSettings.forceWebSockets = settings.forceWebSockets || false;
        socketSettings.compatibilityV2 = settings.compatibilityV2 !== false;
        socketSettings.language = settings.language;

        try {
            let filePath = settings.usePureWebSockets ? require.resolve(`${utils.appName}.ws`) : require.resolve(`${utils.appName}.socketio`);
            filePath = filePath.replace(/\\/g, '/');
            const parts = filePath.split('/');
            parts.pop(); // main.js
            parts.push('lib');
            parts.push('socket.js');
            const IOSocket = require(parts.join('/'));
            // const IOSocket = require('./lib/socket.js'); // DEBUG
            server.io = new IOSocket(server.server, socketSettings, adapter, null, store, checkUser);
        } catch (err) {
            adapter.log.error('Initialization of integrated socket.io failed. Please reinstall the web adapter.');
            if (err.message) {
                adapter.log.error(`ERROR: ${err.message}`);
                adapter.log.error(err.stack);
            } else {
                adapter.log.error(JSON.stringify(err));
            }
        }
    }

    const extensionPromises = [];

    if (!settings.disableExtensions) {
        adapter.log.debug('Activating extensions');
        // activate extensions
        Object.keys(extensions).forEach(instance => {
            try {
                // for debug purposes, try to load file in current directory "/lib/file.js" (elsewise node.js cannot debug it)
                const parts = extensions[instance].path.split('/');
                parts.shift();
                let extAPI;
                if (fs.existsSync(`./${parts.join('/')}`)) {
                    extAPI = require(`./${parts.join('/')}`);
                } else {
                    extAPI = require(`${utils.appName}.${extensions[instance].path}`);
                }

                adapter.log.info(`Connecting extension "${extensions[instance].path}"`);

                extensions[instance].obj = new extAPI(server.server, {secure: settings.secure, port: settings.port}, adapter, extensions[instance].config, server.app);
                if (extensions[instance].obj?.waitForReady && typeof extensions[instance].obj.waitForReady === 'function') {
                    extensionPromises.push(new Promise(resolve => {
                        let timeout = adapter.setTimeout(() => {
                            if (timeout) {
                                timeout = null;
                                adapter.log.error(`Extension "${instance}" (${extensions[instance].path}) is not responding (waitForReady)`);
                                resolve();
                            }
                        }, 5000);

                        const ready = () => {
                            if (timeout) {
                                adapter.log.debug(`Connected extension "${extensions[instance].path}"`);
                                adapter.clearTimeout(timeout);
                                timeout = null;
                                resolve();
                            }
                        };

                        extensions[instance].obj.waitForReady(ready);
                    }));
                }
            } catch (err) {
                adapter.log.error(`Cannot start extension "${instance}": ${err}`);
            }
        });
    }

    Promise.all(extensionPromises)
        .then(() => {
            // Activate integrated simple API
            if (settings.simpleapi) {
                adapter.log.debug('Activating simple API');
                try {
                    const SimpleAPI = require(`${utils.appName}.simple-api/lib/simpleapi.js`);

                    server.api = new SimpleAPI(server.server, {secure: settings.secure, port: settings.port}, adapter);
                } catch (e) {
                    adapter.log.error(`Cannot find simple api module! ${e}`);
                }
            }

            if (server.app && !settings.disableFilesObjects) {
                adapter.log.debug('Activating web files from objectDB');
                // deliver web files from objectDB
                server.app.use('/', (req, res) => {
                    let url = decodeURI(req.url);
                    // remove all ../
                    // important: Linux does not normalize "\" but fs.readFile accepts it as '/'
                    url = path.normalize(url.replace(/\\/g, '/')).replace(/\\/g, '/');
                    // remove '////' at start and let only one
                    if (url[0] === '/' && url[1] === '/') {
                        let i = 2;
                        while (url[i] === '/') {
                            i++;
                        }
                        url = url.substring(i - 1);
                    }
                    if ((url[0] === '.' && url[1] === '.') || (url[0] === '/' && url[1] === '.' && url[2] === '.')) {
                        res.status(404).send('Not found');
                        return;
                    }

                    if (server.api && server.api.checkRequest(url)) {
                        server.api.restApi(req, res);
                        return;
                    }

                    // If root directory requested
                    if (url === '/' || url === '/index.html') {
                        if (adapter.config.defaultRedirect) {
                            res.redirect(301, adapter.config.defaultRedirect);
                            return;
                        } else {
                            getListOfAllAdapters(settings, server, req)
                                .then(data => res
                                    .set('Content-Type', 'text/html')
                                    .set('Cache-Control', 'no-cache')
                                    .status(200)
                                    .send(data))
                                .catch(err => res.status(500).send(`500. Error${escapeHtml(typeof err !== 'string' ? err.toString() : err)}`));
                            return;
                        }
                    }

                    // add index.html
                    url = url.replace(/\/($|\?|#)/, '/index.html$1');

                    if (url.match(/^\/adapter\//)) {
                        // add .admin to adapter name
                        url = url.replace(/^\/adapter\/([a-zA-Z0-9-_]+)\//, '/$1.admin/');
                    }

                    if (url.match(/^\/lib\//)) {
                        url = `/${adapter.name}${url}`;
                    }
                    if (url.match(/^\/admin\//)) {
                        url = `/${adapter.name}${url}`;
                    }
                    url = url.split('/');
                    // Skip first /
                    url.shift();
                    // Get ID
                    const id = url.shift();
                    const versionPrefix = url[0];
                    url = url.join('/');
                    const pos = url.indexOf('?');
                    let noFileCache;
                    if (pos !== -1) {
                        url = url.substring(0, pos);
                        // disable file cache if request like /vis/files/picture.png?noCache
                        noFileCache = true;
                    }

                    // get adapter name
                    if (webByVersion[id]) {
                        if (!versionPrefix || !versionPrefix.match(/^\d+\.\d+.\d+$/)) {
                            // redirect to version
                            res.set('location', `/${id}/${webByVersion[id]}/${url}`);
                            res.status(301).send();
                            return;
                        }
                    }

                    if (settings.cache && cache[`${id}/${url}`] && !noFileCache) {
                        res.contentType(cache[`${id}/${url}`].mimeType);
                        if (req.headers.range) {
                            sendRange(req, res, cache[`${id}/${url}`].buffer);
                        } else {
                            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                            res.status(200).send(cache[`${id}/${url}`].buffer);
                        }
                    } else {
                        if (id === 'login' && url === 'index.html') {
                            loginPage = loginPage || prepareLoginTemplate();
                            const buffer = loginPage;

                            if (!settings.auth || (req.isAuthenticated && req.isAuthenticated()) || isInWhiteList(settings, server, req)) {
                                res.redirect(getRedirectPage(req));
                                return;
                            }

                            if (buffer === null || buffer === undefined) {
                                res.contentType('text/html');
                                res.set('Cache-Control', 'no-cache');
                                res.status(200).send(`File ${escapeHtml(url)} not found`, 404);
                            } else {
                                // Store file in cache
                                if (settings.cache) {
                                    cache[`${id}/${url}`] = {buffer: buffer.toString(), mimeType: 'text/html'};
                                }
                                res.set('Cache-Control', 'no-cache');
                                res.contentType('text/html');
                                res.status(200).send(buffer.toString());
                            }
                        } else {
                            // special solution for socket.io
                            if (url.endsWith('socket.io.js') || url.match(/\/socket\.io\.js(\?.*)?$/)) {
                                getSocketIoFile(req, res, true);
                                return;
                            }

                            adapter.readFile(
                                id,
                                webByVersion[id] && versionPrefix ? url.substring(versionPrefix.length + 1) : url,
                                {
                                    user: req.user ? `system.user.${req.user}` : settings.defaultUser,
                                    noFileCache: noFileCache
                                },
                                (err, buffer, mimeType) => {
                                    if (adapter.config.showFolderIndex && err && err.toString() === 'Error: Not exists' && req.url.endsWith('/')) {
                                        url = url.replace(/\/?index.html$/, '');
                                        // show folder index

                                        const path = webByVersion[id] && versionPrefix ? url.substring(versionPrefix.length + 1) : url;
                                        return adapter.readDir(
                                            id,
                                            path,
                                            {
                                                user: req.user ? `system.user.${req.user}` : settings.defaultUser
                                            },
                                            (err, files) => {
                                                adapter.log.debug(`readDir ${id} (${path}): ${JSON.stringify(files)}`);

                                                res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                                                res.set('Content-Type', 'text/html; charset=utf-8');
                                                const text = [
                                                    '<html>',
                                                    '<head><title>Directory</title>',
                                                    `<style>body { font-family: Arial, sans-serif; } td { padding: 5px; }</style>`,
                                                    `</head><body><h3>Directory ${req.url}</h3><table>`
                                                ];

                                                if (url !== '/') {
                                                    const parts = url.split('/');
                                                    parts.pop();
                                                    text.push(`<tr><td><a href="../">..</a></td><td></td></tr>`);
                                                }

                                                files.sort((a, b) => {
                                                    if (a.isDir && b.isDir) {
                                                        return a.file.localeCompare(b.file);
                                                    } else if (a.isDir) {
                                                        return -1;
                                                    } else if (b.isDir) {
                                                        return 1;
                                                    }

                                                    return a.file.localeCompare(b.file);
                                                });
                                                files.forEach(file =>
                                                    text.push(`<tr><td><a href="./${file.file}${file.isDir ? '/' : ''}" style="${file.isDir ? 'font-weight: bold' : ''}">${file.file}</a></td><td>${(file.stats && file.stats.size) || ''}</td></tr>`));
                                                text.push('</table></body></html>');
                                                res.status(200).send(text.join('\n'));
                                            });
                                    }

                                    if (buffer === null || buffer === undefined || err) {
                                        res.contentType('text/html');
                                        res.status(404).send(`File ${escapeHtml(url)} not found: ${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`);
                                    } else {
                                        mimeType = mimeType || mime.lookup(url) || 'text/javascript';

                                        // replace some important variables in HTML
                                        if (url === 'index.html' || url === 'edit.html') {
                                            buffer = buffer
                                                .toString()
                                                .replaceAll(`@@vendorPrefix@@`, vendorPrefix)

                                                .replaceAll(`'@@disableDataReporting@@'`, adapter.common.disableDataReporting ? 'true' : 'false')
                                                .replaceAll(`"@@disableDataReporting@@"`, adapter.common.disableDataReporting ? 'true' : 'false')

                                                .replaceAll(`@@loadingBackgroundColor@@`, adapter.config.loadingBackgroundColor || '')

                                                .replaceAll(`@@loadingBackgroundImage@@`, adapter.config.loadingBackgroundImage ? `files/${adapter.namespace}/loading-bg.png` : '')

                                                .replaceAll(`'@@loadingHideLogo@@'`, adapter.config.loadingHideLogo ? 'true' : 'false')
                                                .replaceAll(`"@@loadingHideLogo@@"`, adapter.config.loadingHideLogo ? 'true' : 'false');
                                        }

                                        // Store file in cache
                                        if (settings.cache) {
                                            cache[`${id}/${url}`] = { buffer, mimeType };
                                        }

                                        res.contentType(mimeType);

                                        if (req.headers.range) {
                                            sendRange(req, res, buffer);
                                        } else {
                                            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                                            res.status(200).send(buffer);
                                        }
                                    }
                                });
                        }
                    }
                });
            }
        });

    if (server.server) {
        return server;
    } else {
        return null;
    }
}

// If started as allInOne/compact mode => return function to create instance
if (module && module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}

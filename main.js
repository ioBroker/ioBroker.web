/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const express     = require('express');
const fs          = require('fs');
const path        = require('path');
const utils       = require('@iobroker/adapter-core'); // Get common adapter utils
/**
 * TODO: remove LE at some point.
 * @deprecated
 */
const LE     	  = utils.commonTools.letsEncrypt;
const utilsWebServer = utils.commonTools.webServer;
const mime        = require('mime-types');
const adapterName = require('./package.json').name.split('.').pop();
const compression = require('compression');

const ONE_MONTH_SEC = 30 * 24 * 3600;

let session;// =           require('express-session');
let cookieParser;// =      require('cookie-parser');
let bodyParser;// =        require('body-parser');
let AdapterStore;// =      require(__dirname + '/../../lib/session.js')(session);
let passport;// =          require('passport');
let LocalStrategy;// =     require('passport-local').Strategy;
let flash;// =             require('connect-flash'); // TODO report error to user

let webServer    = null;
let store        = null;
let secret       = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let socketUrl    = '';
const cache      = {}; // cached web files
let ownSocket    = false;
let lang         = 'en';
const extensions = {};
const bruteForce = {};
let socketIoFile = null;
const webPreSettings = {};
const webByVersion = {};
let loginPage    = null;
const FORBIDDEN_CHARS = /[\][*,;'"`<>\\\s?]/g; // with space

const LOGIN_PAGE = '/login/index.html';
const wwwDir = 'www';

function getAppName() {
    const parts = __dirname.replace(/\\/g, '/').split('/');
    return parts[parts.length - 1].split('.')[0].toLowerCase();
}
utils.appName = getAppName();

// copied from here: https://github.com/component/escape-html/blob/master/index.js
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml (string) {
    const str = '' + string;
    const match = matchHtmlRegExp.exec(str);

    if (!match) {
        return str;
    }

    let escape;
    let html = '';
    let index;
    let lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escape = '&quot;';
                break;
            case 38: // &
                escape = '&amp;';
                break;
            case 39: // '
                escape = '&#39;';
                break;
            case 60: // <
                escape = '&lt;';
                break;
            case 62: // >
                escape = '&gt;';
                break;
            default:
                continue;
        }

        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }

        lastIndex = index + 1;
        html += escape;
    }

    return lastIndex !== index
        ? html + str.substring(lastIndex, index)
        : html;
}

async function getSocketUrl(obj) {
    if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
        obj = obj || (await adapter.getForeignObjectAsync(adapter.config.socketio));
        if (obj && obj.common && !obj.common.enabled) {
            const state = await adapter.getForeignStateAsync(`${adapter.config.socketio}.alive`);
            if (state && state.val) {
                return `:${obj.native.port}`;
            }
        } else if (obj && obj.common && obj.common.enabled && obj.native) {
            return `:${obj.native.port}`;
        }
    }

    return '';
}

let adapter;
function startAdapter(options) {
    options = options || {};

    Object.assign(options, {
        name: adapterName,
        objectChange: (id, obj) => {
            if (id.startsWith('system.adapter')) {
                if (obj && obj.common && obj.common.webExtension && obj.native &&
                    (extensions[id.substring('system.adapter.'.length)] ||
                        obj.native.webInstance === '*' ||
                        obj.native.webInstance === adapter.namespace
                    )
                ) {
                    return adapter.setForeignState(`system.adapter.${adapter.namespace}.alive`, false, true, () =>
                        adapter.terminate ? adapter.terminate(-100) : process.exit(-100));
                }

                // 'system.adapter.'.length = 15
                const _id = id.substring(15).replace(/\.\d+$/, '');
                if (obj && obj.common && obj.common.webByVersion) {
                    webByVersion[_id] = obj.common.version;
                } else if (webByVersion[_id]) {
                    delete webByVersion[_id];
                }
            }

            if (obj && obj.common && obj.common.webPreSettings) {
                updatePreSettings(obj);
            }

            if (!ownSocket && id === adapter.config.socketio) {
                getSocketUrl(obj)
                    .then(_socketUrl => {
                        socketUrl = _socketUrl;
                        adapter.log.info(`SocketURL now "${socketUrl}"`);
                    });
            }

            if (id === 'system.config' && !adapter.config.language) {
                lang = obj && obj.common && obj.common.language ? obj.common.language : 'en';
            }

            if (webServer && webServer.io) {
                try {
                    webServer.io.publishAll('objectChange', id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot objectChange to io: ${e}`);
                }
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.objectChange && webServer.api.objectChange(id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot call objectChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.objectChange === 'function') {
                        extensions[instance].obj.objectChange(id, obj);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call objectChange for "${instance}": ${err.message}`);
                }
            });
        },
        stateChange: (id, state) => {
            if (webServer && webServer.io) {
                webServer.io.publishAll('stateChange', id, state);
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.stateChange && webServer.api.stateChange(id, state);
                } catch (e) {
                    adapter.log.error(`Cannot call stateChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.stateChange === 'function') {
                        extensions[instance].obj.stateChange(id, state);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call stateChange for "${instance}": ${err.message}`);
                }
            });
        },
        fileChange: (id, fileName, size) => {
            if (webServer && webServer.io) {
                webServer.io.publishFileAll(id, fileName, size);
            }

            if (webServer && webServer.api) {
                try {
                    webServer.api.fileChange && webServer.api.fileChange(id, fileName, size);
                } catch (e) {
                    adapter.log.error(`Cannot call fileChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.fileChange === 'function') {
                        extensions[instance].obj.fileChange(id, fileName, size);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call fileChange for "${instance}": ${err.message}`);
                }
            });
        },
        unload: callback => {
            try {
                const promises = [];

                if (adapter.setStateAsync) {
                    promises.push(adapter.setStateAsync('info.connected', '', true));
                    promises.push(adapter.setStateAsync('info.connection', false, true));
                }

                Object.keys(extensions).forEach(instance => {
                    try {
                        if (extensions[instance] && extensions[instance].obj && extensions[instance].obj.unload) {
                            const promise = extensions[instance].obj.unload();
                            if (promise && typeof promise === 'object' && typeof promise.then === 'function') {
                                promises.push(promise
                                    .catch(e =>
                                        adapter && adapter.log && adapter.log.error(`Cannot unload web extension "${instance}": ${e}`)));
                            }
                        }
                    } catch (e) {
                        adapter && adapter.log && adapter.log.error(`Cannot unload web extension "${instance}": ${e}`);
                    }
                });

                let timeout;
                if (promises.length) {
                    timeout = setTimeout(() => {
                        timeout = null;
                        adapter && adapter.log && adapter.log.warn(`Timeout by termination of web-extensions!`);
                        webServer && webServer.settings && adapter && adapter.log && adapter.log.debug(`terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                        webServer && webServer.io && webServer.io.close();
                        webServer && webServer.server && webServer.server.close();
                        webServer && webServer.settings && adapter && adapter.log && adapter.log.info(`terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                        callback && callback();
                    }, 500);
                }

                Promise.all(promises)
                    .catch(e => adapter && adapter.log && adapter.log.error(`Cannot unload web extensions: ${e}`))
                    .then(() => {
                        if (!promises.length || timeout) {
                            clearTimeout(timeout);
                            timeout = null;
                            webServer && webServer.settings && adapter && adapter.log && adapter.log.debug(`terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                            webServer && webServer.io && webServer.io.close();
                            webServer && webServer.server && webServer.server.close();
                            webServer && webServer.settings && adapter && adapter.log && adapter.log.info(`terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`);
                            callback && callback();
                        }
                    });
            } catch (e) {
                callback();
            }
        },
        ready: async () => {
            // Generate secret for session manager
            const systemConfig = await adapter.getForeignObjectAsync('system.config');

            if (systemConfig) {
                if (!systemConfig.native || !systemConfig.native.secret) {
                    systemConfig.native = systemConfig.native || {};
                    const buf = await new Promise(resolve => require('crypto').randomBytes(24, (ex, buf) => resolve(buf)));
                    secret = buf.toString('hex');
                    await adapter.extendForeignObjectAsync('system.config', {native: {secret}});
                } else {
                    secret = systemConfig.native.secret;
                }
            } else {
                adapter.log.error('Cannot find object system.config');
            }

            // information about connected socket.io adapter
            if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
                socketUrl = await getSocketUrl();
                // Listen for changes
                await adapter.subscribeForeignObjectsAsync(adapter.config.socketio);
            } else {
                socketUrl = adapter.config.socketio;
                ownSocket = socketUrl !== 'none';
            }

            // Read language
            if (adapter.config.language) {
                lang = adapter.config.language;
            } else
            if (systemConfig && systemConfig.common) {
                lang = systemConfig.common.language || 'en';
            }

            main();
        }
    });

    adapter = new utils.Adapter(options);

    return adapter;
}

function extractPreSetting(obj, attr) {
    const parts = attr.split('.');
    if (parts.length === 1) {
        if ((obj && typeof obj === 'object') || (obj !== null && obj !== undefined)) {
            return obj[attr];
        } else {
            return null;
        }
    } else {
        attr = parts.shift();
        if (obj[attr] && typeof obj[attr] === 'object') {
            return extractPreSetting(obj[attr], parts.join('.'));
        } else {
            return null;
        }
    }
}
function updatePreSettings(obj) {
    if (!obj || !obj.common) {
        return;
    }
    if (obj.common.webPreSettings) {
        for (const attr of Object.keys(obj.common.webPreSettings)) {
            webPreSettings[obj._id] = webPreSettings[obj._id] || {};
            const _attr = attr.replace(/[^\w0-9]/g, '_');
            webPreSettings[obj._id][_attr] = extractPreSetting(obj, obj.common.webPreSettings[attr]);
            if (typeof webPreSettings[obj._id][_attr] === 'object') {
                webPreSettings[obj._id][_attr] = JSON.stringify(webPreSettings[obj._id][_attr]);
            } else {
                webPreSettings[obj._id][_attr] = webPreSettings[obj._id][_attr].replace(/"/g, '\\"');
            }
        }
    } else if (webPreSettings[obj._id]) {
        delete webPreSettings[obj._id];
    }
}

function getExtensionsAndSettings(callback) {
    adapter.getObjectView('system', 'instance', null, (err, doc) => {
        if (err) {
            callback && callback(err, []);
        } else {
            if (doc.rows.length === 0) {
                callback && callback(null, []);
            } else {
                const res = [];
                for (let i = 0; i < doc.rows.length; i++) {
                    const instance = doc.rows[i].value;
                    if (instance && instance.common) {
                        if (instance.common.enabled &&
                            instance.common.webExtension &&
                        (instance.native.webInstance === adapter.namespace || instance.native.webInstance === '*')) {

                            // decrypt all native attributes listed in instance.encryptedNative
                            if (Array.isArray(instance.encryptedNative) && instance.native) {
                                instance.encryptedNative.forEach(key => {
                                    if (instance.native[key]) {
                                        instance.native[key] = adapter.decrypt(secret, instance.native[key]);
                                    }
                                });
                            }

                            res.push(instance);
                        }
                        if (instance.common.webPreSettings) {
                            updatePreSettings(instance);
                        }
                        if (instance.common.webByVersion) {
                            // 'system.adapter.'.length = 15
                            const _id = doc.rows[i].value._id.substring(15).replace(/\.\d+$/, '');
                            webByVersion[_id] = instance.common.version;
                        }
                    }
                }
                callback && callback(null, res);
            }
        }
    });
}

function main() {
    getExtensionsAndSettings((err, ext) => {
        err && adapter.log.error(`Cannot read extensions: ${err}`);
        if (ext) {
            for (let e = 0; e < ext.length; e++) {
                if (ext[e] && ext[e].common) {
                    const instance = ext[e]._id.substring('system.adapter.'.length);
                    const name = instance.split('.')[0];

                    extensions[instance] = {
                        path: name + '/' + ext[e].common.webExtension,
                        config: ext[e]
                    };
                }
            }
        }

        // TODO: This whole setting of webServer global is pretty nasty, needs cleaning up.
        initWebServer(adapter.config)
            .then(returnedServer => webServer = returnedServer)
            .catch(err => {
                adapter.log.error(`Failed to initWebServer: ${err}`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            });
        // monitor extensions and pro keys
        adapter.subscribeForeignObjects('system.adapter.*');
    });
}

/* function readDirs(dirs, cb, result) {
    result = result || [];
    if (!dirs || !dirs.length) {
        return cb && cb(result);
    }
    const dir = dirs.shift();
    adapter.readDir(dir, '', (err, files) => {
        if (!err && files && files.length) {
            for (let f = 0; f < files.length; f++) {
                if (files[f].file.match(/\.html$/)) {
                    result.push(dir + '/' + files[f].file);
                }
            }
        }
        setImmediate(readDirs, dirs, cb, result);
    });
}
*/
let indexHtml;

function getLinkVar(_var, obj, attr, link) {
    if (attr === 'protocol') {
        attr = 'secure';
    }

    if (_var === 'ip') {
        link = link.replace(`%${_var}%`, '$host$');
    } else
    if (_var === 'instance') {
        const instance = obj._id.split('.').pop();
        link = link.replace(`%${_var}%`, instance);
    } else {
        if (obj) {
            if (attr.startsWith('native_')) {
                attr = attr.substring(7);
            }

            let val = obj.native[attr];
            if (_var === 'bind' && (!val || val === '0.0.0.0')) {
                val = '$host$';
            }

            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, val ? 'https' : 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, val);
                } else {
                    link = link.replace(`%${_var}%`, val);
                }
            }
        } else {
            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, '');
                } else {
                    link = link.replace(`%${_var}%`, '');
                }
            }
        }
    }

    return link;
}

function resolveLink(link, instanceObj, instancesMap) {
    const vars = link.match(/%(\w+)%/g);
    let _var;
    let v;
    let parts;
    let result;

    if (vars) {
        // first replace simple patterns
        for (v = vars.length - 1; v >= 0; v--) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            parts = _var.split('_');
            // like "port"
            if (_var.startsWith('native_')) {
                link = getLinkVar(_var, instanceObj, _var, link);
                vars.splice(v, 1);
            } else
            if (parts.length === 1) {
                link = getLinkVar(_var, instanceObj, parts[0], link);
                vars.splice(v, 1);
            } else
            // like "web.0_port"
            if (parts[0].match(/\.\d+$/)) {
                link = getLinkVar(_var, instancesMap[`system.adapter.${parts[0]}`], parts[1], link);
                vars.splice(v, 1);
            }
        }

        const links = {};
        let instances;
        const adptr = parts[0];
        // process web_port
        for (v = 0; v < vars.length; v++) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            if (_var.startsWith('native_')) {
                _var = _var.substring(7);
            }

            parts = _var.split('_');
            if (!instances) {
                instances = [];
                // TODO !
                /*for (let inst = 0; inst < 10; inst++) {
                    if (that.main.objects[`system.adapter.${adptr}.${inst}`]) {
                        instances.push(inst);
                    }
                }*/
            }

            for (let i = 0; i < instances.length; i++) {
                links[adptr + '.' + i] = {
                    instance: `${adptr}.${i}`,
                    link: getLinkVar(_var, instancesMap[`system.adapter.${adptr}.${i}`], parts[1], links[`${adptr}.${i}`] ? links[adptr + '.' + i].link : link)
                };
            }
        }
        if (instances) {
            result = [];
            let count = 0;
            let firstLink = '';
            for (const d of Object.keys(links)) {
                result[links[d].instance] = links[d].link;
                firstLink = firstLink || links[d].link;
                count++;
            }
            if (count < 2) {
                link = firstLink;
                result = null;
            }
        }
    }
    return result || link;
}

/*function replaceInLink(link, instanceObj, instances) {
    if (typeof link === 'object') {
        const links = JSON.parse(JSON.stringify(link));
        let first = '';
        for (const v of Object.keys(links)) {
            links[v] = resolveLink(links[v], instanceObj, instances);
            first = first || links[v];
        }
        links.__first = first;
        return links;
    } else {
        return resolveLink(link, instanceObj, instances);
    }
}*/

function processWelcome(welcomeScreen, isPro, adapterObj, foundInstanceIDs, list) {
    if (welcomeScreen) {
        welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
        if (Array.isArray(welcomeScreen)) {
            for (let w = 0; w < welcomeScreen.length; w++) {
                // temporary disabled for non-pro
                if (!isPro && welcomeScreen[w].name === 'vis editor') {
                    continue;
                }
                if (welcomeScreen[w].localLinks && typeof welcomeScreen[w].localLinks === 'string') {
                    welcomeScreen[w].localLink = adapterObj.common.localLinks[welcomeScreen[w].localLinks];
                    if (typeof welcomeScreen[w].localLink === 'object') {
                        welcomeScreen[w].localLink = welcomeScreen[w].localLink.link;
                    }
                } else
                if (welcomeScreen[w].localLink && typeof welcomeScreen[w].localLink === 'boolean') {
                    welcomeScreen[w].localLink = adapterObj.common.localLink;
                }

                welcomeScreen[w].pro = isPro;
                if (welcomeScreen[w].localLink) {
                    if (foundInstanceIDs.length > 1) {
                        foundInstanceIDs.forEach(id => {
                            const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                            _welcomeScreen.id = id;
                            _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                            list.push(_welcomeScreen);
                        });
                    } else {
                        welcomeScreen[w].id = foundInstanceIDs[0];
                        list.push(welcomeScreen[w]);
                    }
                } else {
                    list.push(welcomeScreen[w]);
                }
            }
        } else {
            if (welcomeScreen.localLinks && typeof welcomeScreen.localLinks === 'string') {
                welcomeScreen.localLink = adapterObj.common.localLinks[welcomeScreen.localLinks];
                if (typeof welcomeScreen.localLink === 'object') {
                    welcomeScreen.localLink = welcomeScreen.localLink.link;
                }
            } else
            if (welcomeScreen.localLink && typeof welcomeScreen.localLink === 'boolean') {
                welcomeScreen.localLink = adapterObj.common.localLink;
            }
            welcomeScreen.pro = isPro;
            if (welcomeScreen.localLink) {
                if (foundInstanceIDs.length > 1) {
                    foundInstanceIDs.forEach(id => {
                        const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                        _welcomeScreen.id = id;
                        _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                        list.push(_welcomeScreen);
                    });
                } else {
                    welcomeScreen.id = foundInstanceIDs[0];
                    list.push(welcomeScreen);
                }
            } else {
                list.push(welcomeScreen);
            }
        }
    }
}

function getListOfAllAdapters(settings, server, req, callback) {
    // read all instances
    adapter.getObjectView('system', 'instance', {}, (err, instances) => {
        adapter.getObjectView('system', 'adapter', {}, (err, adapters) => {
            try {
                const list = [];
                const mapInstance = {};
                for (let r = 0; r < instances.rows.length; r++) {
                    mapInstance[instances.rows[r].id] = instances.rows[r].value;
                }
                for (let a = 0; a < adapters.rows.length; a++) {
                    const obj = adapters.rows[a].value;
                    let found;
                    if (instances && instances.rows) {
                        found = [];
                        // find if any instance of this adapter is exists and started
                        for (let i = 0; i < instances.rows.length; i++) {
                            let id = instances.rows[i].id;
                            const ids = id.split('.');
                            ids.pop();
                            id = ids.join('.');
                            if (id === obj._id && instances.rows[i].value.common && (true || instances.rows[i].value.common.enabled || instances.rows[i].value.common.onlyWWW)) {
                                found.push(instances.rows[i].id);
                            }
                        }
                    }

                    if (found && found.length) {
                        processWelcome(obj.common.welcomeScreen, false, obj, found, list);
                        processWelcome(obj.common.welcomeScreenPro, true, obj, found, list);
                        /*if (obj.common.welcomeScreen || obj.common.welcomeScreenPro) {
                            if (obj.common.welcomeScreen) {
                                if (obj.common.welcomeScreen instanceof Array) {
                                    for (let w = 0; w < obj.common.welcomeScreen.length; w++) {
                                        // temporary disabled
                                        if (obj.common.welcomeScreen[w].name === 'vis editor') {
                                            continue;
                                        }
                                        if (obj.common.welcomeScreen[w].localLinks && typeof obj.common.welcomeScreen[w].localLinks === 'string') {
                                            obj.common.welcomeScreen[w].localLink = obj.common.localLinks[obj.common.welcomeScreen[w].localLinks];
                                            if (typeof obj.common.welcomeScreen[w].localLink === 'object') {
                                                obj.common.welcomeScreen[w].localLink = obj.common.welcomeScreen[w].localLink.link;
                                            }
                                        } else
                                        if (obj.common.welcomeScreen[w].localLink && typeof obj.common.welcomeScreen[w].localLink === 'boolean') {
                                            obj.common.welcomeScreen[w].localLink = obj.common.localLink;
                                        }

                                        if (obj.common.welcomeScreen[w].localLink) {
                                            if (found.length > 1) {
                                                found.forEach(id => {
                                                    const welcomeScreen = JSON.stringify(JSON.parse(obj.common.welcomeScreen[w]));
                                                    welcomeScreen.id = id;
                                                    list.push(welcomeScreen);
                                                });
                                            } else {
                                                obj.common.welcomeScreen[w].id = found[0];
                                                list.push(obj.common.welcomeScreen[w]);
                                            }
                                        } else {
                                            list.push(obj.common.welcomeScreen[w]);
                                        }
                                    }
                                } else {
                                    if (obj.common.welcomeScreen.localLinks && typeof obj.common.welcomeScreen.localLinks === 'string') {
                                        obj.common.welcomeScreen.localLink = obj.common.localLinks[obj.common.welcomeScreen.localLinks];
                                        if (typeof obj.common.welcomeScreen.localLink === 'object') {
                                            obj.common.welcomeScreen.localLink = obj.common.welcomeScreen.localLink.link;
                                        }
                                    } else
                                    if (obj.common.welcomeScreen.localLink && typeof obj.common.welcomeScreen.localLink === 'boolean') {
                                        obj.common.welcomeScreen.localLink = obj.common.localLink;
                                    }

                                    if (obj.common.welcomeScreen.localLink) {
                                        if (found.length > 1) {
                                            found.forEach(id => {
                                                const welcomeScreen = JSON.stringify(JSON.parse(obj.common.welcomeScreen));
                                                welcomeScreen.id = id;
                                                list.push(welcomeScreen);
                                            });
                                        } else {
                                            obj.common.welcomeScreen.id = found[0];
                                            list.push(obj.common.welcomeScreen);
                                        }
                                    } else {
                                        list.push(obj.common.welcomeScreen);
                                    }
                                }
                            }
                            if (obj.common.welcomeScreenPro) {
                                if (obj.common.welcomeScreenPro instanceof Array) {
                                    for (let ww = 0; ww < obj.common.welcomeScreenPro.length; ww++) {
                                        const tile = Object.assign({}, obj.common.welcomeScreenPro[ww]);
                                        tile.pro = true;
                                        if (tile.localLinks && typeof tile.localLinks === 'string') {
                                            tile.localLink = obj.common.localLinks[tile.localLinks];
                                            if (typeof tile.localLink === 'object') {
                                                tile.localLink = tile.localLink.link;
                                            }
                                        } else
                                        if (tile.localLink && typeof tile.localLink === 'boolean') {
                                            tile.localLink = obj.common.localLink;
                                        }
                                        if (tile.localLink) {
                                            tile.id = found;
                                        }
                                        list.push(tile);
                                    }
                                } else {
                                    const tile_ = Object.assign({}, obj.common.welcomeScreenPro);
                                    tile_.pro = true;
                                    if (tile_.localLinks && typeof tile_.localLinks === 'string') {
                                        tile_.localLink = obj.common.localLinks[tile_.localLinks];
                                        if (typeof tile_.localLink === 'object') {
                                            tile_.localLink = tile_.localLink.link;
                                        }
                                    } else
                                    if (tile_.localLink && typeof tile_.localLink === 'boolean') {
                                        tile_.localLink = obj.common.localLink;
                                    }
                                    if (tile_.localLink) {
                                        if (found.length > 1) {
                                            found.forEach(id => {
                                                const welcomeScreen = JSON.stringify(JSON.parse(obj.common.tile_));
                                                welcomeScreen.id = id;
                                                list.push(welcomeScreen);
                                            });
                                        } else {
                                            tile_.id = found[0];
                                            list.push(obj.common.welcomeScreen);
                                        }
                                    } else {
                                        list.push(tile_);
                                    }
                                }
                            }
                        }*/
                    }
                }

                if (!indexHtml && !fs.existsSync(`${__dirname}/${wwwDir}/index.html`)) {
                    return callback(null, `${__dirname}/${wwwDir}/index.html was not found or no access! Check the file or access rights or start the fixer: "curl -sL https://iobroker.net/fix.sh | bash -"`);
                }

                indexHtml = indexHtml || fs.readFileSync(`${__dirname}/${wwwDir}/index.html`).toString();

                // calculate localLinks
                for (let t = 0; t < list.length; t++) {
                    if (list[t].localLink) {
                        list[t].localLink = resolveLink(list[t].localLink, mapInstance[list[t].id], mapInstance);
                    }
                }

                // try to find swagger web-extension
                // inform extensions
                Object.keys(extensions).forEach(instance => {
                    try {
                        if (extensions[instance].obj && typeof extensions[instance].obj.welcomePage === 'function') {
                            list.push(extensions[instance].obj.welcomePage());
                        }
                    } catch (err) {
                        adapter.log.error(`Cannot call welcomePage for "${instance}": ${err.message}`);
                    }
                });

                list.sort((a, b) => {
                    const aName = (typeof a.name === 'object' ? a.name[lang] || a.name.en : a.name).toLowerCase();
                    const bName = (typeof b.name === 'object' ? b.name[lang] || b.name.en : b.name).toLowerCase();
                    if (a.order === undefined && b.order === undefined) {
                        if (aName > bName) {
                            return 1;
                        }
                        if (aName < bName) {
                            return -1;
                        }
                        return 0;
                    } else if (a.order === undefined) {
                        return -1;
                    } else if (b.order === undefined) {
                        return 1;
                    } else {
                        if (a.order > b.order) {
                            return 1;
                        }
                        if (a.order < b.order) {
                            return -1;
                        }
                        if (aName > bName) {
                            return 1;
                        }
                        if (aName < bName) {
                            return -1;
                        }
                        if (a.instance !== undefined && b.instance !== undefined) {
                            if (a.instance > b.instance) {
                                return 1;
                            }
                            if (a.instance < b.instance) {
                                return -1;
                            }
                        }

                        return 0;
                    }
                });

                let text = `systemLang = "${lang}";\n`;
                text += `list = ${JSON.stringify(list, null, 2)};\n`;

                const whiteListIp = isInWhiteList(settings, server, req);

                // if login
                text += `let authEnabled = ${adapter.config.auth && !adapter.config.basicAuth && !whiteListIp};\n`;

                callback(null, indexHtml.replace('// -- PLACE THE LIST HERE --', text));
            } catch (e) {
                callback(e);
            }
        });
    });

}

function getInfoJs(settings) {
    const result = [
        `var socketUrl = "${socketUrl}";`,
        `var socketSession = "";`,
        `window._authIoBroker = ${settings.auth};`,
        `window.sysLang = "${lang}";`,
        `window.socketForceWebSockets = ${settings.forceWebSockets ? 'true' : 'false'};`
    ];
    for (const id of Object.keys(webPreSettings)) {
        if (webPreSettings[id]) {
            for (const attr of Object.keys(webPreSettings[id])) {
                result.push(`window.${attr} = "${webPreSettings[id][attr]}";`);
            }
        }
    }
    return result.join(' ');
}

function prepareLoginTemplate() {
    let def =
        '            font: 13px/20px \'Lucida Grande\', Tahoma, Verdana, sans-serif;\n' +
        '            color: #404040;\n' +
        '            background-color: #0ae;\n' +
        '            background-image: -webkit-gradient(linear, 0 0, 0 100%, color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.5, transparent), to(transparent));\n' +
        '            background-image: -webkit-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -moz-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -ms-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -o-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-size: 50px 50px;\n'
    ;
    const template = fs.readFileSync(`${__dirname}/${wwwDir}${LOGIN_PAGE}`).toString('utf8');
    if (adapter.config.loginBackgroundColor) {
        def = `background-color: ${adapter.config.loginBackgroundColor};\n`;
    }
    if (adapter.config.loginBackgroundImage) {
        def += `            background-image: url(../${adapter.namespace}/login-bg.png);\n`;
    }
    return template.replace('background: black;', def);
}

function checkUser(username, password, cb) {
    username = (username || '').toString().replace(FORBIDDEN_CHARS, '_').replace(/\s/g, '_').replace(/\./g, '_').toLowerCase();

    if (bruteForce[username] && bruteForce[username].errors > 4) {
        let minutes = Date.now() - bruteForce[username].time;
        if (bruteForce[username].errors < 7) {
            if (Date.now() - bruteForce[username].time < 60000) {
                minutes = 1;
            } else {
                minutes = 0;
            }
        } else
        if (bruteForce[username].errors < 10) {
            if (Date.now() - bruteForce[username].time < 180000) {
                minutes = Math.ceil((180000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else
        if (bruteForce[username].errors < 15) {
            if (Date.now() - bruteForce[username].time < 600000) {
                minutes = Math.ceil((600000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else
        if (Date.now() - bruteForce[username].time < 3600000) {
            minutes = Math.ceil((3600000 - minutes) / 60000);
        } else {
            minutes = 0;
        }

        if (minutes) {
            return cb(`Too many errors. Try again in ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}.`, false);
        }
    }

    adapter.checkPassword(username, password, res => {
        if (!res) {
            bruteForce[username] = bruteForce[username] || {errors: 0};
            bruteForce[username].time = Date.now();
            bruteForce[username].errors++;
        } else if (bruteForce[username]) {
            delete bruteForce[username];
        }

        if (res) {
            return cb(null, username);
        } else {
            return cb(null, false);
        }
    });
}

function initAuth(server, settings) {
    session       = require('express-session');
    cookieParser  = require('cookie-parser');
    bodyParser    = require('body-parser');
    AdapterStore  = utils.commonTools.session(session, settings.ttl);
    passport      = require('passport');
    LocalStrategy = require('passport-local').Strategy;
    flash         = require('connect-flash'); // TODO report error to user

    store = new AdapterStore({adapter});

    passport.use(new LocalStrategy(checkUser));

    passport.serializeUser((user, done) => done(null, user));

    passport.deserializeUser((user, done) => done(null, user));

    server.app.use(cookieParser());
    server.app.use(bodyParser.urlencoded({extended: true}));
    server.app.use(bodyParser.json());
    server.app.use(bodyParser.text());
    server.app.use(session({
        secret,
        saveUninitialized: true,
        resave:            true,
        cookie:            {maxAge: settings.ttl * 1000, httpOnly: false}, // default TTL
        store
    }));
    server.app.use(passport.initialize());
    server.app.use(passport.session());
    server.app.use(flash());
}

/**
 * Send response to a byte ranges request
 *
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {Buffer} buffer - buffer to be sent
 * @returns {void}
 */
function sendRange(req, res, buffer) {
    /** @type {Record<string, number>[]} */
    const ranges = req.range(buffer.length);

    if (ranges.length > 1) {
        adapter.log.warn('Multiple ranges currently not supported, sending whole buffer');
        res.status(200).send(buffer);
        return;
    }

    // This is for <video> tag on iOS Safari, only one range is used by Safari, so this is enough for now
    const range = ranges[0] || {start: 0, end: buffer.length};
    res.set('Content-Range', `bytes ${range.start}-${range.end}/${buffer.length}`);
    const buf = buffer.slice(range.start, range.end + 1);
    res.set('Content-Length', buf.length);
    res.status(206).send(buf);
}

function getSocketIoFile(req, res, next) {
    if (next === true || req.url.endsWith('socket.io.js') || req.url.match(/\/socket\.io\.js(\?.*)?$/)) {
        if (socketIoFile) {
            res.contentType('text/javascript');
            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
            return res.status(200).send(socketIoFile);
        } else {
            // if used internal socket io, so deliver @iobroker/ws
            if ((!adapter.config.socketio && adapter.config.usePureWebSockets) || adapter.config.socketio.startsWith('system.adapter.ws.')) {
                let file;
                // If debug version stored
                if (fs.existsSync(`${__dirname}/www/lib/js/ws.js`)) {
                    file =`${__dirname}/www/lib/js/ws.js`;
                } else {
                    const pathToFile = require.resolve(`${utils.appName}.ws`);
                    file = path.join(path.dirname(pathToFile), '/lib/socket.io.js');
                }
                socketIoFile = fs.readFileSync(file);
            } else {
                // try to get file from iobroker.socketio adapter
                let file;
                try {
                    const dir = require.resolve(`${utils.appName}.socketio`);
                    file = path.join(path.dirname(dir), '/lib/socket.io.js');
                } catch (e) {
                    // ignore
                }

                if (file && fs.existsSync(file)) {
                    socketIoFile = fs.readFileSync(file);
                } else {
                    try {
                        // try to get socket.io-client
                        const dir = require.resolve('socket.io-client');
                        const fileDir = path.join(path.dirname(dir), '../dist/');
                        if (fs.existsSync(fileDir + 'socket.io.min.js')) {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.min.js`);
                        } else {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.js`);
                        }
                    } catch (e) {
                        try {
                            // if nothing works, read stored in web file
                            socketIoFile = fs.readFileSync(`${__dirname}/${wwwDir}/lib/js/socket.io.js`);
                        } catch (e) {
                            adapter.log.error(`Cannot read socket.io.js: ${e}`);
                            socketIoFile = false;
                        }
                    }
                }
            }

            if (socketIoFile) {
                res.contentType('text/javascript');
                res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                return res.status(200).send(socketIoFile);
            } else {
                socketIoFile = false;
                return res.status(404).end();
            }
        }
    } else {
        next();
    }
}

function getRedirectPage(req) {
    let redirect = '../';
    let parts;
    req.body = req.body || {};
    // const isDev = req.url.includes('?dev&');

    const origin = req.body.origin || '?href=%2F';

    if (origin) {
        parts = origin.split('=');
        if (parts.length > 1 && parts[1]) {
            redirect = decodeURIComponent(parts[1]);
            // if some invalid characters in redirect
            if (redirect.match(/[^-_a-zA-Z0-9&%?./]/)) {
                redirect = '../';
            }
        }
    }

    return redirect;
}

function isInWhiteList(settings, server, req) {
    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    if (!adapter.config.auth) {
        return remoteIp;
    } else
    if (settings.whiteListSettings) {
        // if whitelist is used
        let whiteListIp = server.io && server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
        if (!whiteListIp && server.io && remoteIp === '::1') {
            whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
        }

        if (whiteListIp && settings.whiteListSettings[whiteListIp].user !== 'auth') {
            adapter.log.silly(`whiteListIp ${whiteListIp}`);
            return whiteListIp;
        } else {
            adapter.log.debug(`Request from "${remoteIp}". Must authenticate, as IP not found in the white list`);
        }
    }

    return '';
}

//settings: {
//    "port":   8080,
//    "auth":   false,
//    "secure": false,
//    "bind":   "0.0.0.0", // "::"
//    "cache":  false
//}
async function initWebServer(settings) {
    /**
     * Old way of doing things is to use individual certificate settings and load here.
     * Don't bother if these config values are not set.
     * TODO: remove this code at some point.
     * @deprecated
     */
    if (settings.secure && settings.certPublic && settings.certPrivate) {
        adapter.log.warn('Looks like old certificate configuration is in place, consider updating this');
        // Load certificates and/or get Lets Encrypt config.
        const certObj = await adapter.getCertificatesAsync();
        settings.certificates = certObj[0];
        settings.leConfig = certObj[1];
        if (!settings.certificates) {
            adapter.log.error('Failed to load old certificates');
            return null;
        }
    }

    const server = {
        app:       null,
        server:    null,
        io:        null,
        settings:  settings
    };
    adapter.subscribeForeignObjects('system.config');

    settings.ttl = parseInt(settings.ttl, 10) || 3600;

    if (settings.ttl < 30) {
        settings.ttl = 30;
    }

    if (!settings.whiteListEnabled && settings.whiteListSettings) {
        delete settings.whiteListSettings;
    }

    settings.defaultUser = settings.defaultUser || 'system.user.admin';
    if (!settings.defaultUser.startsWith('system.user.')) {
        settings.defaultUser = `system.user.${settings.defaultUser}`;
    }

    if (settings.port) {
        server.app = express();
        server.app.use(compression());

        server.app.disable('x-powered-by');
        // enable use of i-frames together with HTTPS
        // todo find the admin port and bind and use it here "ALLOW-FROM ipbind:port"
        // try to add "Content-Security-Policy: frame-ancestors 'self' example.com *.example.net ;"
        /*
        server.app.get('/*', (req, res, next) => {
            res.header('X-Frame-Options' , 'SAMEORIGIN');
            next(); // http://expressjs.com/guide.html#passing-route control
        });
        */

        // replace socket.io
        server.app.use((req, res, next) => getSocketIoFile(req, res, next));

        if (settings.auth) {
            initAuth(server, settings);

            /**
             * Authenticates at the server with the given username and password provided in req
             *
             * @param {object} req - request object having properties username and password
             * @param {object} res - response object
             * @param {function} next - express next function
             * @param {string} redirect - redirect path
             * @param {string} origin - origin path
             */
            const authenticate = (req, res, next, redirect, origin) => {
                passport.authenticate('local', (err, user) => {
                    if (err) {
                        adapter.log.warn(`Cannot login user: ${err}`);
                        return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                    }
                    if (!user) {
                        return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                    }
                    req.logIn(user, err => {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                        if (req.body.stayLoggedIn) {
                            req.session.cookie.maxAge = settings.ttl > ONE_MONTH_SEC ? settings.ttl * 1000 : ONE_MONTH_SEC * 1000;
                        } else {
                            req.session.cookie.maxAge = settings.ttl * 1000;
                        }
                        return res.redirect(redirect);
                    });
                })(req, res, next);
            };

            /**
             * Auto Logon if possible else it will redirect or return Basic Auth information if activated
             *
             * @param {Request} req - request object
             * @param {Response} res - response object
             * @param {function} next - next function of express
             * @param {string} redirect - redirect path
             * @returns {void|*|Response}
             */
            const autoLogonOrRedirectToLogin = (req, res, next, redirect) => {
                let isJs;
                if (/\.css(\?.*)?$/.test(req.originalUrl)) {
                    res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                    return res.status(200).send('');
                } else
                if ((isJs = /\.js(\?.*)?$/.test(req.originalUrl))) {
                    // return always valid js file for js, because if cache is active it leads to errors
                    const parts = req.originalUrl.split('/');
                    parts.shift();

                    // if request for web/lib, ignore it, because no redirect information
                    if (parts[0] === 'lib') {
                        res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                        return res.status(200).send('');
                    }
                }

                const whiteListIp = isInWhiteList(settings, server, req);

                // if not authenticated
                if (!whiteListIp) {
                    if (isJs) {
                        return res.status(200).send(`document.location="${LOGIN_PAGE}?href=" + encodeURI(location.href.replace(location.origin, ""));`);
                    } else if (adapter.config.basicAuth) {
                        // if basic auth active, we tell it by sending header with 401 status
                        res.set('WWW-Authenticate', `Basic realm="Access to ioBroker web", charset="UTF-8"`);
                        return res.status(401).send('Basic Authentication has been aborted. You have to reload the page.');
                    } else {
                        return res.redirect(redirect);
                    }
                }

                req.logIn(settings.whiteListSettings[whiteListIp].user, err => next(err));
            };

            server.app.post('/login', (req, res, next) => {
                let redirect = getRedirectPage(req);

                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                if (req.body.username && settings.addUserName && !redirect.includes('?')) {
                    const parts = redirect.split('#');
                    parts[0] += `?${req.body.username}`;
                    redirect = parts.join('#');
                }

                authenticate(req, res, next, redirect, req.body.origin || '?href=%2F');
            });

            server.app.get('/logout', (req, res) => {
                const isDev = req.url.includes('?dev');
                req.logout(() => {
                    if (isDev) {
                        res.redirect('http://localhost:3000/index.html?login');
                    } else {
                        res.redirect(LOGIN_PAGE);
                    }
                });
            });

            // route middleware to make sure a user is logged in
            server.app.use((req, res, next) => {
                // return favicon always
                if (req.originalUrl.endsWith('favicon.ico')) {
                    res.set('Content-Type', 'image/x-icon');
                    return res.send(fs.readFileSync(`${__dirname}/${wwwDir}/login/favicon.ico`));
                }
                // if cache.manifest got back not 200 it makes an error
                if (req.isAuthenticated() ||
                    /web\.\d+\/login-bg\.png(\?.*)?$/.test(req.originalUrl) ||
                    /cache\.manifest(\?.*)?$/.test(req.originalUrl) ||
                    /^\/login\//.test(req.originalUrl) ||
                    /\.ico(\?.*)?$/.test(req.originalUrl)
                ) {
                    return next();
                } else if (adapter.config.basicAuth && typeof req.headers.authorization === 'string' && req.headers.authorization.startsWith('Basic')) {
                    // not logged in yet and basic auth is active + header present
                    const b64auth = req.headers.authorization.split(' ')[1];
                    const [login, password] = Buffer.from(b64auth, 'base64').toString().split(':');

                    req.body = req.body || {};

                    req.body.username = login;
                    req.body.password = password;
                    req.body.stayLoggedIn = req.body.stayloggedin === 'true' || req.body.stayloggedin === true || req.body.stayloggedin === 'on';

                    const origin = req.body.origin || '?href=%2F';
                    const redirect = req.originalUrl;

                    authenticate(req, res, next, redirect, origin);
                } else {
                    // not logged in yet, redirect, auto login or send 401 if basicAuth activated
                    autoLogonOrRedirectToLogin(req, res, next, `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`);
                }
            });

            // todo
            server.app.get('/prolongSession', (req, res, next) => {
                if (req.isAuthenticated()) {
                    req.session.touch();
                    const parts = req.headers.cookie.split(';');
                    const cookie = {};
                    parts.forEach(item => {
                        const [name, value] = item.split('=');
                        cookie[name.trim()] = value;
                    });

                    if (cookie['connect.sid']) {
                        store && store.get(req.session.id, (err, obj) => {
                            // obj = {"cookie":{"originalMaxAge":2592000000,"expires":"2020-09-24T18:09:50.377Z","httpOnly":true,"path":"/"},"passport":{"user":"admin"}}
                            if (obj) {
                                const expires = new Date();
                                //expires.setMilliseconds(expires.getMilliseconds() + req.session.cookie.maxAge);

                                obj.cookie.expires = expires.toISOString();
                                console.log(`Session ${req.session.id} expires on ${obj.cookie.expires}`);

                                store.set(req.session.id, obj);
                                //res.cookie('connect.sid', cookie['connect.sid'], { maxAge: req.session.cookie.maxAge, httpOnly: true });
                                res.send(obj.cookie.expires);
                            } else {
                                res.status(501).send('cannot prolong');
                            }
                        });
                    } else {
                        res.status(501).send('cannot prolong');
                    }
                } else {
                    autoLogonOrRedirectToLogin(req, res, next, `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`);
                }
            });
        } else {
            server.app.get('/login', (req, res) => res.redirect('/'));
            server.app.get('/logout', (req, res) => res.redirect('/'));

            if (settings.whiteListEnabled) {
                initAuth(server, settings);
                server.app.use((req, res, next) => {
                    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
                    let whiteListIp = server.io && server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
                    if (!whiteListIp && server.io && remoteIp === '::1') {
                        whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
                    }
                    adapter.log.silly('whiteListIp ' + whiteListIp);
                    if (whiteListIp) {
                        req.logIn(settings.whiteListSettings[whiteListIp].user, err =>
                            next(err));
                    } else {
                        req.logIn(settings.defaultUser.substr(12), err => // cut "system.user."
                            next(err));
                    }
                });
            }
        }

        if (!settings.disableStates) {
            adapter.log.debug('Activating states & socket info');
            // Init read from states
            server.app.get('/state/*', (req, res) => {
                try {
                    const fileName = req.url.split('/', 3)[2].split('?', 2);
                    adapter.getForeignObject(fileName[0], (err, obj) => {
                        let contentType = 'text/plain';
                        if (obj && obj.common.type === 'file')  {
                            contentType = mime.lookup(fileName[0]);
                        }
                        if (obj && obj.common.type === 'file') {
                            const getForeignBinaryState = adapter.getForeignBinaryState || adapter.getBinaryState;
                            getForeignBinaryState.call(adapter, fileName[0], {user: req.user ? `system.user.${req.user}` : settings.defaultUser}, (err, obj) => {
                                if (!err && obj !== null && obj !== undefined) {
                                    if (obj && typeof obj === 'object' && obj.val !== undefined && obj.ack !== undefined) {
                                        res.set('Content-Type', 'application/json');
                                    } else {
                                        res.set('Content-Type', contentType || 'text/plain');
                                    }
                                    res.set('Cache-Control', 'no-cache');
                                    res.status(200).send(obj);
                                } else {
                                    res.status(404).send(`404 Not found. File ${escapeHtml(fileName[0])} not found`);
                                }
                            });
                        } else {
                            adapter.getForeignState(fileName[0], {user: req.user ? `system.user.${req.user}` : settings.defaultUser}, (err, obj) => {
                                if (!err && obj !== null && obj !== undefined) {
                                    res.set('Content-Type', 'text/plain');
                                    res.set('Cache-Control', 'no-cache');
                                    if (fileName[1] && fileName[1].includes('json')) {
                                        res.status(200).send(JSON.stringify(obj));
                                    } else {
                                        res.status(200).send(obj.val === undefined ? 'undefined' :
                                            (obj.val === null ? 'null' :
                                                (typeof obj.val === 'object' ? JSON.stringify(obj.val) : obj.val.toString())));
                                    }
                                } else {
                                    res.status(404).send(`404 Not found. File ${escapeHtml(fileName[0])} not found`);
                                }
                            });
                        }
                    });
                } catch (e) {
                    res.status(500).send(`500. Error${e}`);
                }
            });
        }

        server.app.get('*/_socket/info.js', (req, res) => {
            res.set('Content-Type', 'application/javascript');
            res.set('Cache-Control', 'no-cache');
            res.status(200).send(getInfoJs(settings));
        });

        // Enable CORS
        if (settings.socketio) {
            server.app.use((req, res, next) => {
                res.header('Access-Control-Allow-Origin', '*');
                res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
                res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With, *');

                // intercept OPTIONS method
                if ('OPTIONS' === req.method) {
                    res.status(200).send(200);
                } else {
                    next();
                }
            });
        }

        const appOptions = {};
        if (settings.cache) {
            appOptions.maxAge = 30758400000; // one year
        }

        if (!settings.certificates) {
            // 'new' - maybe not when you read this ;) - certificate collection method
            server.server = await utilsWebServer.createServer(server.app, settings, adapter);
        } else {
            /**
             * TODO: This is the old way - remove this code at some point
             * @deprecated
             */
            try {
                if (typeof LE.createServerAsync === 'function') {
                    server.server = await LE.createServerAsync(server.app, settings, settings.certificates, settings.leConfig, adapter.log, adapter);
                } else {
                    server.server = LE.createServer(server.app, settings, settings.certificates, settings.leConfig, adapter.log);
                }
            } catch (err) {
                adapter.log.error(`Cannot create web-server: ${err}`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
                return;
            }
        }
        if (!server.server) {
            adapter.log.error(`Cannot create web-server`);
            adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }

        server.server.__server = server;
    } else {
        adapter.log.error('port missing');
        adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    }

    if (server.server) {
        let serverListening = false;
        let serverPort;
        server.server.on('error', e => {
            if (e.toString().includes('EACCES') && serverPort <= 1024) {
                adapter.log.error(`node.js process has no rights to start server on the port ${serverPort}.\n` +
                    `Do you know that on linux you need special permissions for ports under 1024?\n` +
                    `You can call in shell following scrip to allow it for node.js: "iobroker fix"`
                );
            } else {
                adapter.log.error(`Cannot start server on ${settings.bind || '0.0.0.0'}:${serverPort}: ${e}`);
            }
            if (!serverListening) {
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION) : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
        });

        settings.port = parseInt(settings.port, 10) || 8082;
        serverPort = settings.port;

        adapter.getPort(settings.port, (!settings.bind || settings.bind === '0.0.0.0') ? undefined : settings.bind || undefined, port => {
            port = parseInt(port, 10);
            if (port !== settings.port && !settings.findNextPort) {
                adapter.log.error(`port ${settings.port} already in use`);
                adapter.terminate ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION): process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
            serverPort = port;
            server.server.listen(port, (!settings.bind || settings.bind === '0.0.0.0') ? undefined : settings.bind || undefined, () => {
                serverListening = true;
                adapter.setState('info.connection', true, true);
            });

            adapter.log.info(`http${settings.secure ? 's' : ''} server listening on port ${port}`);
        });
    }

    // Activate integrated socket
    if (ownSocket) {
        adapter.log.debug('Activating IOSocket');
        const socketSettings = JSON.parse(JSON.stringify(settings));
        // Authentication checked by server itself
        socketSettings.auth = settings.auth;
        socketSettings.secret = secret;
        socketSettings.store = store;
        socketSettings.ttl = settings.ttl || 3600;
        socketSettings.forceWebSockets = settings.forceWebSockets || false;
        socketSettings.compatibilityV2 = settings.compatibilityV2 !== false;
        socketSettings.language = settings.language;

        try {
            let filePath = settings.usePureWebSockets ? require.resolve(`${utils.appName}.ws`) : require.resolve(`${utils.appName}.socketio`);
            filePath = filePath.replace(/\\/g, '/');
            const parts = filePath.split('/');
            parts.pop(); // main.js
            parts.push('lib');
            parts.push('socket.js');
            const IOSocket = require(parts.join('/'));
            // const IOSocket = require('./lib/socket.js'); // DEBUG
            server.io = new IOSocket(server.server, socketSettings, adapter, null, store, checkUser);
        } catch (err) {
            adapter.log.error('Initialization of integrated socket.io failed. Please reinstall the web adapter.');
            if (err.message) {
                adapter.log.error(`ERROR: ${err.message}`);
                adapter.log.error(err.stack);
            } else {
                adapter.log.error(JSON.stringify(err));
            }
        }
    }

    const extensionPromises = [];

    if (!settings.disableExtensions) {
        adapter.log.debug('Activating extensions');
        // activate extensions
        Object.keys(extensions).forEach(instance => {
            try {
                // for debug purposes try to load file in current directory "/lib/file.js" (elsewise node.js cannot debug it)
                const parts = extensions[instance].path.split('/');
                parts.shift();
                let extAPI;
                if (fs.existsSync(`./${parts.join('/')}`)) {
                    extAPI = require(`./${parts.join('/')}`);
                } else {
                    extAPI = require(`${utils.appName}.${extensions[instance].path}`);
                }

                extensions[instance].obj = new extAPI(server.server, {secure: settings.secure, port: settings.port}, adapter, extensions[instance].config, server.app);
                if (extensions[instance].obj.waitForReady) {
                    extensionPromises.push(new Promise(resolve => extensions[instance].obj.waitForReady(resolve)));
                }
                adapter.log.info(`Connect extension "${extensions[instance].path}"`);
            } catch (err) {
                adapter.log.error(`Cannot start extension "${instance}": ${err}`);
            }
        });
    }

    Promise.all(extensionPromises)
        .then(() => {
            // Activate integrated simple API
            if (settings.simpleapi) {
                adapter.log.debug('Activating simple API');
                try {
                    const SimpleAPI = require(`${utils.appName}.simple-api/lib/simpleapi.js`);

                    server.api = new SimpleAPI(server.server, {secure: settings.secure, port: settings.port}, adapter);
                } catch (e) {
                    adapter.log.error(`Cannot find simple api module! ${e}`);
                }
            }

            if (server.app && !settings.disableFilesObjects) {
                adapter.log.debug('Activating web files from objectDB');
                // deliver web files from objectDB
                server.app.use('/', (req, res) => {
                    let url = decodeURI(req.url);
                    // remove all ../
                    // important: Linux does not normalize "\" but fs.readFile accepts it as '/'
                    url = path.normalize(url.replace(/\\/g, '/')).replace(/\\/g, '/');
                    // remove '////' at start and let only one
                    if (url[0] === '/' && url[1] === '/') {
                        let i = 2;
                        while (url[i] === '/') {
                            i++;
                        }
                        url = url.substring(i - 1);
                    }
                    if ((url[0] === '.' && url[1] === '.') || (url[0] === '/' && url[1] === '.' && url[2] === '.')) {
                        return res.status(404).send('Not found');
                    }

                    if (server.api && server.api.checkRequest(url)) {
                        return server.api.restApi(req, res);
                    }

                    if (url === '/' || url === '/index.html') {
                        if (adapter.config.defaultRedirect) {
                            return res.redirect(301, adapter.config.defaultRedirect);
                        } else {
                            return getListOfAllAdapters(settings, server, req, (err, data) => {
                                if (err) {
                                    res.status(500).send(`500. Error${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`);
                                } else {
                                    res
                                        .set('Content-Type', 'text/html')
                                        .set('Cache-Control', 'no-cache')
                                        .status(200)
                                        .send(data);
                                }
                            });
                        }
                    }

                    // add index.html
                    url = url.replace(/\/($|\?|#)/, '/index.html$1');

                    if (url.match(/^\/adapter\//)) {
                        // add .admin to adapter name
                        url = url.replace(/^\/adapter\/([a-zA-Z0-9-_]+)\//, '/$1.admin/');
                    }

                    if (url.match(/^\/lib\//)) {
                        url = '/' + adapter.name + url;
                    }
                    if (url.match(/^\/admin\//)) {
                        url = '/' + adapter.name + url;
                    }
                    url = url.split('/');
                    // Skip first /
                    url.shift();
                    // Get ID
                    const id = url.shift();
                    const versionPrefix = url[0];
                    url = url.join('/');
                    const pos = url.indexOf('?');
                    let noFileCache;
                    if (pos !== -1) {
                        url = url.substring(0, pos);
                        // disable file cache if request like /vis/files/picture.png?noCache
                        noFileCache = true;
                    }

                    // get adapter name
                    if (webByVersion[id]) {
                        if (!versionPrefix || !versionPrefix.match(/^\d+\.\d+.\d+$/)) {
                            // redirect to version
                            res.set('location', `/${id}/${webByVersion[id]}/${url}`);
                            return res.status(301).send();
                        }
                    }

                    if (settings.cache && cache[`${id}/${url}`] && !noFileCache) {
                        res.contentType(cache[`${id}/${url}`].mimeType);
                        if (req.headers.range) {
                            sendRange(req, res, cache[`${id}/${url}`].buffer);
                        } else {
                            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                            res.status(200).send(cache[`${id}/${url}`].buffer);
                        }
                    } else {
                        if (id === 'login' && url === 'index.html') {
                            loginPage = loginPage || prepareLoginTemplate();
                            const buffer = loginPage;

                            if (req.isAuthenticated() || isInWhiteList(settings, server, req)) {
                                return res.redirect(getRedirectPage(req));
                            }

                            if (buffer === null || buffer === undefined) {
                                res.contentType('text/html');
                                res.set('Cache-Control', 'no-cache');
                                res.status(200).send(`File ${escapeHtml(url)} not found`, 404);
                            } else {
                                // Store file in cache
                                if (settings.cache) {
                                    cache[`${id}/${url}`] = {buffer: buffer.toString(), mimeType: 'text/html'};
                                }
                                res.set('Cache-Control', 'no-cache');
                                res.contentType('text/html');
                                res.status(200).send(buffer.toString());
                            }
                        } else {
                            // special solution for socket.io
                            if (url.endsWith('socket.io.js') || url.match(/\/socket\.io\.js(\?.*)?$/)) {
                                return getSocketIoFile(req, res, true);
                            }

                            adapter.readFile(id, webByVersion[id] && versionPrefix ? url.substring(versionPrefix.length + 1) : url, {user: req.user ? 'system.user.' + req.user : settings.defaultUser, noFileCache: noFileCache}, (err, buffer, mimeType) => {
                                if (buffer === null || buffer === undefined || err) {
                                    res.contentType('text/html');
                                    res.status(404).send(`File ${escapeHtml(url)} not found: ${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`);
                                } else {
                                    mimeType = mimeType || mime.lookup(url) || 'text/javascript';

                                    // Store file in cache
                                    if (settings.cache) {
                                        cache[`${id}/${url}`] = {buffer, mimeType};
                                    }

                                    res.contentType(mimeType);

                                    if (req.headers.range) {
                                        sendRange(req, res, buffer);
                                    } else {
                                        res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                                        res.status(200).send(buffer);
                                    }
                                }
                            });
                        }
                    }
                });
            }
        });

    if (server.server) {
        return server;
    } else {
        return null;
    }
}

// If started as allInOne/compact mode => return function to create instance
if (module && module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}

/* jshint -W097 */
/* jshint strict: false */
/* jslint node: true */
'use strict';

const express = require('express');
const fs = require('node:fs');
const path = require('node:path');
const utils = require('@iobroker/adapter-core'); // Get common adapter utils
const IoBWebServer = require('@iobroker/webserver');
const mime = require('mime-types');
const adapterName = require('./package.json').name.split('.').pop();
const compression = require('compression');
const signature = require('cookie-signature');

const ONE_MONTH_SEC = 30 * 24 * 3600;

let session; // =           require('express-session');
let cookieParser; // =      require('cookie-parser');
let bodyParser; // =        require('body-parser');
let AdapterStore; // =      require(__dirname + '/../../lib/session.js')(session);
let passport; // =          require('passport');
let LocalStrategy; // =     require('passport-local').Strategy;
let flash; // =             require('connect-flash'); // TODO report error to user
let checkTimeout;
let vendorPrefix;

let webServer = null;
let store = null;
let secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let socketUrl = '';
const cache = {}; // cached web files
let ownSocket = false;
let lang = 'en';
const extensions = {};
const bruteForce = {};
let socketIoFile = null;
const webPreSettings = {};
const webByVersion = {};
let loginPage = null;
const FORBIDDEN_CHARS = /[\][*,;'"`<>\\\s?]/g; // with space
let groups = null;
let users = null;

const LOGIN_PAGE = '/login/index.html';
const wwwDir = 'www';

function getAppName() {
    const parts = __dirname.replace(/\\/g, '/').split('/');
    return parts[parts.length - 1].split('.')[0].toLowerCase();
}
utils.appName = getAppName();

// copied from here: https://github.com/component/escape-html/blob/master/index.js
const matchHtmlRegExp = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = matchHtmlRegExp.exec(str);

    if (!match) {
        return str;
    }

    let escape;
    let html = '';
    let index;
    let lastIndex = 0;

    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escape = '&quot;';
                break;
            case 38: // &
                escape = '&amp;';
                break;
            case 39: // '
                escape = '&#39;';
                break;
            case 60: // <
                escape = '&lt;';
                break;
            case 62: // >
                escape = '&gt;';
                break;
            default:
                continue;
        }

        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }

        lastIndex = index + 1;
        html += escape;
    }

    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}

async function getSocketUrl(obj) {
    if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
        obj = obj || (await adapter.getForeignObjectAsync(adapter.config.socketio));
        if (obj && obj.common && !obj.common.enabled) {
            const state = await adapter.getForeignStateAsync(`${adapter.config.socketio}.alive`);
            if (state && state.val) {
                return `:${obj.native.port}`;
            }
        } else if (obj && obj.common && obj.common.enabled && obj.native) {
            return `:${obj.native.port}`;
        }
    }

    return '';
}

let adapter;
function startAdapter(options) {
    options = options || {};

    Object.assign(options, {
        name: adapterName,
        objectChange: (id, obj) => {
            if (groups && id.startsWith('system.group.')) {
                if (obj) {
                    groups[id] = obj;
                } else {
                    delete groups[id];
                }
            }
            if (users && id.startsWith('system.user.')) {
                if (obj) {
                    users[id] = obj;
                } else {
                    delete users[id];
                }
            }

            if (id.startsWith('system.adapter')) {
                if (
                    obj?.common?.webExtension &&
                    obj.native &&
                    (extensions[id.substring('system.adapter.'.length)] ||
                        obj.native.webInstance === '*' ||
                        obj.native.webInstance === adapter.namespace)
                ) {
                    return adapter.setForeignState(`system.adapter.${adapter.namespace}.alive`, false, true, () =>
                        adapter.terminate ? adapter.terminate(-100) : process.exit(-100),
                    );
                }

                // 'system.adapter.'.length = 15
                const _id = id.substring(15).replace(/\.\d+$/, '');
                if (obj && obj.common && obj.common.webByVersion) {
                    webByVersion[_id] = obj.common.version;
                } else if (webByVersion[_id]) {
                    delete webByVersion[_id];
                }
            }

            if (obj?.common?.webPreSettings) {
                updatePreSettings(obj);
            }

            if (!ownSocket && id === adapter.config.socketio) {
                getSocketUrl(obj).then(_socketUrl => {
                    socketUrl = _socketUrl;
                    adapter.log.info(`SocketURL now "${socketUrl}"`);
                });
            }

            if (id === 'system.config' && !adapter.config.language) {
                lang = obj?.common?.language || 'en';
            }

            if (webServer && webServer.io) {
                try {
                    webServer.io.publishAll('objectChange', id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot objectChange to io: ${e}`);
                }
            }

            if (webServer?.api?.objectChange) {
                try {
                    webServer.api.objectChange(id, obj);
                } catch (e) {
                    adapter.log.error(`Cannot call objectChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.objectChange === 'function') {
                        extensions[instance].obj.objectChange(id, obj);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call objectChange for "${instance}": ${err.message}`);
                }
            });
        },
        stateChange: (id, state) => {
            webServer?.io?.publishAll('stateChange', id, state);

            if (webServer?.api?.stateChange) {
                try {
                    webServer.api.stateChange(id, state);
                } catch (e) {
                    adapter.log.error(`Cannot call stateChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.stateChange === 'function') {
                        extensions[instance].obj.stateChange(id, state);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call stateChange for "${instance}": ${err.message}`);
                }
            });
        },
        fileChange: (id, fileName, size) => {
            webServer?.io?.publishFileAll(id, fileName, size);

            if (webServer?.api?.fileChange) {
                try {
                    webServer.api.fileChange(id, fileName, size);
                } catch (e) {
                    adapter.log.error(`Cannot call fileChange for simple api: ${e.message}`);
                }
            }

            // inform extensions
            Object.keys(extensions).forEach(instance => {
                try {
                    if (extensions[instance].obj && typeof extensions[instance].obj.fileChange === 'function') {
                        extensions[instance].obj.fileChange(id, fileName, size);
                    }
                } catch (err) {
                    adapter.log.error(`Cannot call fileChange for "${instance}": ${err.message}`);
                }
            });
        },
        message: msg => {
            if (msg?.command === 'getUserByCookie') {
                let cookie = (msg.message?.cookie || '').toString();

                // extract cookie
                if (cookie.includes('connect.sid=')) {
                    const cookies = cookie.split(';');
                    cookie = cookies
                        .find(cookie => cookie.trim().startsWith('connect.sid='))
                        .replace('connect.sid=', '')
                        .trim();
                }

                // decrypt cookie
                if (cookie) {
                    try {
                        cookie = signature.unsign(decodeURIComponent(cookie).slice(2), secret);
                    } catch (e) {
                        adapter.log.warn(`Cannot decrypt cookie: ${e}`);
                    }
                }

                // get session by cookie
                if (store && cookie && msg.callback) {
                    store.get(cookie, (error, session) => {
                        adapter.sendTo(msg.from, msg.command, { error, user: session?.passport?.user }, msg.callback);
                    });
                } else if (msg.callback) {
                    adapter.sendTo(msg.from, msg.command, { error: 'cookie not found' }, msg.callback);
                }
            } else if (msg?.command === 'im') {
                // if not instance message
                if (webServer?.io) {
                    // to make messages shorter, we code the answer as:
                    // m - message type
                    // s - socket ID
                    // d - data

                    webServer.io.publishInstanceMessageAll(msg.from, msg.message.m, msg.message.s, msg.message.d);
                }
            }
        },
        unload: callback => {
            if (checkTimeout) {
                adapter.clearTimeout(checkTimeout);
                checkTimeout = null;
            }

            try {
                const promises = [];

                if (adapter.setStateAsync) {
                    promises.push(adapter.setStateAsync('info.connected', '', true));
                    promises.push(adapter.setStateAsync('info.connection', false, true));
                }

                Object.keys(extensions).forEach(instance => {
                    try {
                        if (extensions?.[instance]?.obj?.unload) {
                            const promise = extensions[instance].obj.unload();
                            if (promise && typeof promise === 'object' && typeof promise.then === 'function') {
                                promises.push(
                                    promise.catch(
                                        e =>
                                            adapter &&
                                            adapter.log &&
                                            adapter.log.error(`Cannot unload web extension "${instance}": ${e}`),
                                    ),
                                );
                            }
                        }
                    } catch (e) {
                        adapter && adapter.log && adapter.log.error(`Cannot unload web extension "${instance}": ${e}`);
                    }
                });

                let timeout;
                if (promises.length) {
                    timeout = adapter.setTimeout(() => {
                        timeout = null;
                        adapter?.log?.warn(`Timeout by termination of web-extensions!`);
                        webServer?.settings &&
                            adapter?.log?.debug(
                                `terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`,
                            );
                        webServer?.io?.close();
                        webServer?.server?.close();
                        webServer?.settings &&
                            adapter?.log?.info(
                                `terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`,
                            );
                        callback && callback();
                    }, 500);
                }

                Promise.all(promises)
                    .catch(e => adapter && adapter.log && adapter.log.error(`Cannot unload web extensions: ${e}`))
                    .then(() => {
                        if (!promises.length || timeout) {
                            adapter.clearTimeout(timeout);
                            timeout = null;
                            webServer?.settings &&
                                adapter?.log?.debug(
                                    `terminating http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`,
                                );
                            webServer?.io?.close();
                            webServer?.server?.close();
                            webServer?.settings &&
                                adapter?.log?.info(
                                    `terminated http${webServer.settings.secure ? 's' : ''} server on port ${webServer.settings.port}`,
                                );
                            if (callback) {
                                callback();
                            }
                        }
                    });
            } catch (e) {
                callback();
            }
        },
        ready: async () => {
            // Generate secret for session manager
            const systemConfig = await adapter.getForeignObjectAsync('system.config');

            if (systemConfig) {
                if (!systemConfig.native || !systemConfig.native.secret) {
                    systemConfig.native = systemConfig.native || {};
                    const buf = await new Promise(resolve =>
                        require('crypto').randomBytes(24, (ex, buf) => resolve(buf)),
                    );
                    secret = buf.toString('hex');
                    await adapter.extendForeignObjectAsync('system.config', { native: { secret } });
                } else {
                    secret = systemConfig.native.secret;
                }
            } else {
                adapter.log.error('Cannot find object system.config');
            }

            let uuid = null;
            try {
                uuid = await adapter.getForeignObjectAsync('system.meta.uuid');
            } catch (e) {
                adapter.log.warn(`Cannot read UUID: ${e}`);
            }
            vendorPrefix =
                systemConfig?.native?.vendor?.uuidPrefix ||
                (uuid?.native?.uuid?.length > 36 ? uuid.native.uuid.substring(0, 2) : '');

            // information about connected socket.io adapter
            if (adapter.config.socketio && adapter.config.socketio.match(/^system\.adapter\./)) {
                socketUrl = await getSocketUrl();
                // Listen for changes
                await adapter.subscribeForeignObjectsAsync(adapter.config.socketio);
            } else {
                socketUrl = adapter.config.socketio;
                ownSocket = socketUrl !== 'none';
            }

            // Read language
            if (adapter.config.language) {
                lang = adapter.config.language;
            } else if (systemConfig && systemConfig.common) {
                lang = systemConfig.common.language || 'en';
            }

            main();
        },
    });

    adapter = new utils.Adapter(options);

    return adapter;
}

function extractPreSetting(obj, attr) {
    const parts = attr.split('.');
    if (parts.length === 1) {
        if ((obj && typeof obj === 'object') || (obj !== null && obj !== undefined)) {
            return obj[attr];
        } else {
            return null;
        }
    } else {
        attr = parts.shift();
        if (obj[attr] && typeof obj[attr] === 'object') {
            return extractPreSetting(obj[attr], parts.join('.'));
        } else {
            return null;
        }
    }
}

function updatePreSettings(obj) {
    if (!obj || !obj.common) {
        return;
    }
    if (obj.common.webPreSettings) {
        for (const attr of Object.keys(obj.common.webPreSettings)) {
            webPreSettings[obj._id] = webPreSettings[obj._id] || {};
            const _attr = attr.replace(/[^\w0-9]/g, '_');
            webPreSettings[obj._id][_attr] = extractPreSetting(obj, obj.common.webPreSettings[attr]);
            if (typeof webPreSettings[obj._id][_attr] === 'object') {
                webPreSettings[obj._id][_attr] = JSON.stringify(webPreSettings[obj._id][_attr]);
            } else {
                webPreSettings[obj._id][_attr] = webPreSettings[obj._id][_attr].replace(/"/g, '\\"');
            }
        }
    } else if (webPreSettings[obj._id]) {
        delete webPreSettings[obj._id];
    }
}

function getExtensionsAndSettings(callback) {
    adapter.getObjectView('system', 'instance', null, (err, doc) => {
        if (err) {
            callback && callback(err, []);
        } else {
            if (!doc.rows?.length) {
                callback && callback(null, []);
            } else {
                const res = [];
                for (let i = 0; i < doc.rows.length; i++) {
                    const instance = doc.rows[i].value;
                    if (instance && instance.common) {
                        if (
                            (adapter.config.startDisabledExtensions || instance.common.enabled) &&
                            instance.common.webExtension &&
                            (instance.native.webInstance === adapter.namespace || instance.native.webInstance === '*')
                        ) {
                            // decrypt all native attributes listed in instance.encryptedNative
                            if (Array.isArray(instance.encryptedNative) && instance.native) {
                                instance.encryptedNative.forEach(key => {
                                    if (instance.native[key]) {
                                        instance.native[key] = adapter.decrypt(secret, instance.native[key]);
                                    }
                                });
                            }

                            res.push(instance);
                        }
                        if (instance.common.webPreSettings) {
                            updatePreSettings(instance);
                        }
                        if (instance.common.webByVersion) {
                            // 'system.adapter.'.length = 15
                            const _id = doc.rows[i].value._id.substring(15).replace(/\.\d+$/, '');
                            webByVersion[_id] = instance.common.version;
                        }
                    }
                }
                if (callback) {
                    callback(null, res);
                }
            }
        }
    });
}

function main() {
    getExtensionsAndSettings(async (err, ext) => {
        if (err) {
            adapter.log.error(`Cannot read extensions: ${err}`);
        }
        if (ext) {
            for (let e = 0; e < ext.length; e++) {
                if (ext[e] && ext[e].common) {
                    const instance = ext[e]._id.substring('system.adapter.'.length);
                    const name = instance.split('.')[0];

                    extensions[instance] = {
                        path: `${name}/${ext[e].common.webExtension}`,
                        config: ext[e],
                    };
                }
            }
        }
        if (adapter.config.userListSettings) {
            try {
                const _users = await adapter.getObjectViewAsync('system', 'user', {
                    startkey: 'system.user.',
                    endkey: 'system.user.\u9999',
                });
                users = {};
                for (let u = 0; u < _users.rows.length; u++) {
                    users[_users.rows[u].value._id] = _users.rows[u].value;
                }
            } catch (e) {
                adapter.log.error(`Cannot read users: ${e}`);
            }
            try {
                const _groups = await adapter.getObjectViewAsync('system', 'group', {
                    startkey: 'system.group.',
                    endkey: 'system.group.\u9999',
                });
                groups = {};
                for (let u = 0; u < _groups.rows.length; u++) {
                    groups[_groups.rows[u].value._id] = _groups.rows[u].value;
                }
            } catch (e) {
                adapter.log.error(`Cannot read users: ${e}`);
            }
            await adapter.subscribeForeignObjectsAsync('system.user.*');
            await adapter.subscribeForeignObjectsAsync('system.group.*');
        }

        // TODO: This whole setting of webServer global is pretty nasty, needs cleaning up.
        initWebServer(adapter.config)
            .then(returnedServer => (webServer = returnedServer))
            .catch(err => {
                adapter.log.error(`Failed to initWebServer: ${err}`);
                adapter.terminate
                    ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
                    : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            });
        // monitor extensions and pro keys
        adapter.subscribeForeignObjects('system.adapter.*');
    });
}

let indexHtml;

function getLinkVar(_var, obj, attr, link) {
    if (attr === 'protocol') {
        attr = 'secure';
    }

    if (_var === 'ip') {
        link = link.replace(`%${_var}%`, '$host$');
    } else if (_var === 'instance') {
        const instance = obj._id.split('.').pop();
        link = link.replace(`%${_var}%`, instance);
    } else {
        if (obj) {
            if (attr.startsWith('native_')) {
                attr = attr.substring(7);
            }

            let val = obj.native[attr];
            if (_var === 'bind' && (!val || val === '0.0.0.0')) {
                val = '$host$';
            }

            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, val ? 'https' : 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, val);
                } else {
                    link = link.replace(`%${_var}%`, val);
                }
            }
        } else {
            if (attr === 'secure') {
                link = link.replace(`%${_var}%`, 'http');
            } else {
                if (!link.includes(`%${_var}%`)) {
                    link = link.replace(`%native_${_var}%`, '');
                } else {
                    link = link.replace(`%${_var}%`, '');
                }
            }
        }
    }

    return link;
}

function resolveLink(link, instanceObj, instancesMap) {
    const vars = link.match(/%(\w+)%/g);
    let _var;
    let v;
    let parts;
    let result;

    if (vars) {
        // first replace simple patterns
        for (v = vars.length - 1; v >= 0; v--) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            parts = _var.split('_');
            // like "port"
            if (_var.startsWith('native_')) {
                link = getLinkVar(_var, instanceObj, _var, link);
                vars.splice(v, 1);
            } else if (parts.length === 1) {
                link = getLinkVar(_var, instanceObj, parts[0], link);
                vars.splice(v, 1);
            } else if (parts[0].match(/\.\d+$/)) {
                // like "web.0_port"
                link = getLinkVar(_var, instancesMap[`system.adapter.${parts[0]}`], parts[1], link);
                vars.splice(v, 1);
            }
        }

        const links = {};
        let instances;
        const adptr = parts[0];
        // process web_port
        for (v = 0; v < vars.length; v++) {
            _var = vars[v];
            _var = _var.replace(/%/g, '');

            if (_var.startsWith('native_')) {
                _var = _var.substring(7);
            }

            parts = _var.split('_');
            if (!instances) {
                instances = [];
                // TODO !
                /*for (let inst = 0; inst < 10; inst++) {
                    if (that.main.objects[`system.adapter.${adptr}.${inst}`]) {
                        instances.push(inst);
                    }
                }*/
            }

            for (let i = 0; i < instances.length; i++) {
                links[adptr + '.' + i] = {
                    instance: `${adptr}.${i}`,
                    link: getLinkVar(
                        _var,
                        instancesMap[`system.adapter.${adptr}.${i}`],
                        parts[1],
                        links[`${adptr}.${i}`] ? links[adptr + '.' + i].link : link,
                    ),
                };
            }
        }
        if (instances) {
            result = [];
            let count = 0;
            let firstLink = '';
            for (const d of Object.keys(links)) {
                result[links[d].instance] = links[d].link;
                firstLink = firstLink || links[d].link;
                count++;
            }
            if (count < 2) {
                link = firstLink;
                result = null;
            }
        }
    }
    return result || link;
}

/*function replaceInLink(link, instanceObj, instances) {
    if (typeof link === 'object') {
        const links = JSON.parse(JSON.stringify(link));
        let first = '';
        for (const v of Object.keys(links)) {
            links[v] = resolveLink(links[v], instanceObj, instances);
            first = first || links[v];
        }
        links.__first = first;
        return links;
    } else {
        return resolveLink(link, instanceObj, instances);
    }
}*/

function processWelcome(welcomeScreen, isPro, adapterObj, foundInstanceIDs, list) {
    if (welcomeScreen) {
        welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
        if (Array.isArray(welcomeScreen)) {
            for (let w = 0; w < welcomeScreen.length; w++) {
                // temporarily disabled for non-pro
                if (!isPro && welcomeScreen[w].name === 'vis editor') {
                    continue;
                }
                if (welcomeScreen[w].localLinks && typeof welcomeScreen[w].localLinks === 'string') {
                    welcomeScreen[w].localLink = adapterObj.common.localLinks[welcomeScreen[w].localLinks];
                    if (typeof welcomeScreen[w].localLink === 'object') {
                        welcomeScreen[w].localLink = welcomeScreen[w].localLink.link;
                    }
                } else if (welcomeScreen[w].localLink && typeof welcomeScreen[w].localLink === 'boolean') {
                    welcomeScreen[w].localLink = adapterObj.common.localLink;
                }

                welcomeScreen[w].pro = isPro;
                if (welcomeScreen[w].localLink) {
                    if (foundInstanceIDs.length > 1) {
                        foundInstanceIDs.forEach(id => {
                            const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen[w]));
                            _welcomeScreen.id = id;
                            _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                            list.push(_welcomeScreen);
                        });
                    } else {
                        welcomeScreen[w].id = foundInstanceIDs[0];
                        list.push(welcomeScreen[w]);
                    }
                } else {
                    list.push(welcomeScreen[w]);
                }
            }
        } else {
            if (welcomeScreen.localLinks && typeof welcomeScreen.localLinks === 'string') {
                welcomeScreen.localLink = adapterObj.common.localLinks[welcomeScreen.localLinks];
                if (typeof welcomeScreen.localLink === 'object') {
                    welcomeScreen.localLink = welcomeScreen.localLink.link;
                }
            } else if (welcomeScreen.localLink && typeof welcomeScreen.localLink === 'boolean') {
                welcomeScreen.localLink = adapterObj.common.localLink;
            }
            welcomeScreen.pro = isPro;
            if (welcomeScreen.localLink) {
                if (foundInstanceIDs.length > 1) {
                    foundInstanceIDs.forEach(id => {
                        const _welcomeScreen = JSON.parse(JSON.stringify(welcomeScreen));
                        _welcomeScreen.id = id;
                        _welcomeScreen.instance = parseInt(id.split('.').pop(), 10);
                        list.push(_welcomeScreen);
                    });
                } else {
                    welcomeScreen.id = foundInstanceIDs[0];
                    list.push(welcomeScreen);
                }
            } else {
                list.push(welcomeScreen);
            }
        }
    }
}

async function getListOfAllAdapters(settings, server, req) {
    // read all instances
    const instances = await adapter.getObjectViewAsync('system', 'instance', {});
    const adapters = await adapter.getObjectViewAsync('system', 'adapter', {});
    const list = [];
    const mapInstance = {};
    for (let r = 0; r < instances.rows.length; r++) {
        mapInstance[instances.rows[r].id] = instances.rows[r].value;
    }
    for (let a = 0; a < adapters.rows.length; a++) {
        const obj = adapters.rows[a].value;
        let found;
        if (instances && instances.rows) {
            found = [];
            // find if any instance of this adapter exists and started
            for (let i = 0; i < instances.rows.length; i++) {
                let id = instances.rows[i].id;
                const ids = id.split('.');
                ids.pop();
                id = ids.join('.');
                if (
                    id === obj._id &&
                    instances.rows[i].value.common
                    // && (true || instances.rows[i].value.common.enabled || instances.rows[i].value.common.onlyWWW)
                ) {
                    found.push(instances.rows[i].id);
                }
            }
        }

        if (found && found.length) {
            try {
                processWelcome(obj.common.welcomeScreen, false, obj, found, list);
                processWelcome(obj.common.welcomeScreenPro, true, obj, found, list);
            } catch (e) {
                adapter.log.warn(`Cannot process welcome screen for "${obj._id}": ${e}`);
            }
        }
    }

    if (!indexHtml && !fs.existsSync(`${__dirname}/${wwwDir}/index.html`)) {
        return `${__dirname}/${wwwDir}/index.html was not found or no access! Check the file or access rights or start the fixer: "curl -sL https://iobroker.net/fix.sh | bash -"`;
    }

    indexHtml = indexHtml || fs.readFileSync(`${__dirname}/${wwwDir}/index.html`).toString();

    // calculate localLinks
    for (let t = 0; t < list.length; t++) {
        if (list[t].localLink) {
            list[t].localLink = resolveLink(list[t].localLink, mapInstance[list[t].id], mapInstance);
        }
        if (!list[t].name) {
            list[t].name = list[t].title;
        }
    }

    // try to find swagger web-extension
    // inform extensions
    Object.keys(extensions).forEach(instance => {
        try {
            if (
                extensions?.[instance]?.obj?.welcomePage &&
                typeof extensions[instance].obj.welcomePage === 'function'
            ) {
                list.push(extensions[instance].obj.welcomePage());
            }
        } catch (err) {
            adapter.log.error(`Cannot call welcomePage for "${instance}": ${err.message}`);
        }
    });

    list.sort((a, b) => {
        const aName = (typeof a.name === 'object' ? a.name[lang] || a.name.en : a.name).toLowerCase();
        const bName = (typeof b.name === 'object' ? b.name[lang] || b.name.en : b.name).toLowerCase();
        if (a.order === undefined && b.order === undefined) {
            if (aName > bName) {
                return 1;
            }
            if (aName < bName) {
                return -1;
            }
            return 0;
        } else if (a.order === undefined) {
            return -1;
        } else if (b.order === undefined) {
            return 1;
        } else {
            if (a.order > b.order) {
                return 1;
            }
            if (a.order < b.order) {
                return -1;
            }
            if (aName > bName) {
                return 1;
            }
            if (aName < bName) {
                return -1;
            }
            if (a.instance !== undefined && b.instance !== undefined) {
                if (a.instance > b.instance) {
                    return 1;
                }
                if (a.instance < b.instance) {
                    return -1;
                }
            }

            return 0;
        }
    });

    let text = `systemLang = "${lang}";\n`;
    text += `list = ${JSON.stringify(list, null, 2)};\n`;

    const whiteListIp = isInWhiteList(settings, server, req);

    // if login
    text += `let authEnabled = ${adapter.config.auth && !adapter.config.basicAuth && !whiteListIp};\n`;

    return indexHtml.replace('// -- PLACE THE LIST HERE --', text);
}

function getInfoJs(settings) {
    const result = [
        `var socketUrl = "${socketUrl}";`,
        `var socketSession = "";`,
        `window._authIoBroker = ${settings.auth};`,
        `window.sysLang = "${lang}";`,
        `window.socketForceWebSockets = ${settings.forceWebSockets ? 'true' : 'false'};`,
    ];
    for (const id of Object.keys(webPreSettings)) {
        if (webPreSettings[id]) {
            for (const attr of Object.keys(webPreSettings[id])) {
                result.push(`window.${attr} = "${webPreSettings[id][attr]}";`);
            }
        }
    }
    return result.join(' ');
}

function prepareLoginTemplate() {
    let def =
        "            font: 13px/20px 'Lucida Grande', Tahoma, Verdana, sans-serif;\n" +
        '            color: #404040;\n' +
        '            background-color: #0ae;\n' +
        '            background-image: -webkit-gradient(linear, 0 0, 0 100%, color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.5, transparent), to(transparent));\n' +
        '            background-image: -webkit-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -moz-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -ms-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: -o-linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-image: linear-gradient(rgba(255, 255, 255, .2) 50%, transparent 50%, transparent);\n' +
        '            background-size: 50px 50px;\n';
    const template = fs.readFileSync(`${__dirname}/${wwwDir}${LOGIN_PAGE}`).toString('utf8');
    if (adapter.config.loginBackgroundColor) {
        def = `background-color: ${adapter.config.loginBackgroundColor};\n`;
    }
    if (adapter.config.loginBackgroundImage) {
        def += `            background-image: url(../${adapter.namespace}/login-bg.png);\n`;
    }
    return template.replace('background: black;', def);
}

function checkUser(username, password, cb) {
    username = (username || '')
        .toString()
        .replace(FORBIDDEN_CHARS, '_')
        .replace(/\s/g, '_')
        .replace(/\./g, '_')
        .toLowerCase();

    if (bruteForce[username] && bruteForce[username].errors > 4) {
        let minutes = Date.now() - bruteForce[username].time;
        if (bruteForce[username].errors < 7) {
            if (Date.now() - bruteForce[username].time < 60000) {
                minutes = 1;
            } else {
                minutes = 0;
            }
        } else if (bruteForce[username].errors < 10) {
            if (Date.now() - bruteForce[username].time < 180000) {
                minutes = Math.ceil((180000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else if (bruteForce[username].errors < 15) {
            if (Date.now() - bruteForce[username].time < 600000) {
                minutes = Math.ceil((600000 - minutes) / 60000);
            } else {
                minutes = 0;
            }
        } else if (Date.now() - bruteForce[username].time < 3600000) {
            minutes = Math.ceil((3600000 - minutes) / 60000);
        } else {
            minutes = 0;
        }

        if (minutes) {
            return cb(`Too many errors. Try again in ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}.`, false);
        }
    }

    adapter.checkPassword(username, password, res => {
        if (!res) {
            bruteForce[username] = bruteForce[username] || { errors: 0 };
            bruteForce[username].time = Date.now();
            bruteForce[username].errors++;
        } else if (bruteForce[username]) {
            delete bruteForce[username];
        }

        if (res) {
            return cb(null, username);
        } else {
            return cb(null, false);
        }
    });
}

function initAuth(server, settings) {
    session = require('express-session');
    cookieParser = require('cookie-parser');
    bodyParser = require('body-parser');
    AdapterStore = utils.commonTools.session(session, settings.ttl);
    passport = require('passport');
    LocalStrategy = require('passport-local').Strategy;
    flash = require('connect-flash'); // TODO report error to user

    store = new AdapterStore({ adapter });

    passport.use(new LocalStrategy(checkUser));

    passport.serializeUser((user, done) => done(null, user));

    passport.deserializeUser((user, done) => done(null, user));

    server.app.use(cookieParser());
    server.app.use(bodyParser.urlencoded({ extended: true }));
    server.app.use(bodyParser.json());
    server.app.use(bodyParser.text());
    server.app.use(
        session({
            secret,
            saveUninitialized: true,
            resave: true,
            cookie: { maxAge: settings.ttl * 1000, httpOnly: false }, // default TTL
            store,
        }),
    );
    server.app.use(passport.initialize());
    server.app.use(passport.session());
    server.app.use(flash());
}

/**
 * Send response to a byte ranges request
 *
 * @param {object} req - request object
 * @param {object} res - response object
 * @param {Buffer} buffer - buffer to be sent
 * @returns {void}
 */
function sendRange(req, res, buffer) {
    /** @type {Record<string, number>[]} */
    const ranges = req.range(buffer.length);

    if (ranges.length > 1) {
        adapter.log.warn('Multiple ranges currently not supported, sending whole buffer');
        res.status(200).send(buffer);
        return;
    }

    // This is for <video> tag on iOS Safari, only one range is used by Safari, so this is enough for now
    const range = ranges[0] || { start: 0, end: buffer.length };
    res.set('Content-Range', `bytes ${range.start}-${range.end}/${buffer.length}`);
    const buf = buffer.slice(range.start, range.end + 1);
    res.set('Content-Length', buf.length);
    res.status(206).send(buf);
}

function getSocketIoFile(req, res, next) {
    if (next === true || req.url.endsWith('socket.io.js') || req.url.match(/\/socket\.io\.js(\?.*)?$/)) {
        if (socketIoFile) {
            res.contentType('text/javascript');
            res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
            return res.status(200).send(socketIoFile);
        } else {
            // if used internal socket io, so deliver @iobroker/ws
            if (
                (!adapter.config.socketio && adapter.config.usePureWebSockets) ||
                adapter.config.socketio.startsWith('system.adapter.ws.')
            ) {
                let file;
                // If debug version stored
                if (fs.existsSync(`${__dirname}/www/lib/js/ws.js`)) {
                    file = `${__dirname}/www/lib/js/ws.js`;
                } else {
                    const pathToFile = require.resolve(`${utils.appName}.ws`);
                    file = path.join(path.dirname(pathToFile), '/lib/socket.io.js');
                }
                socketIoFile = fs.readFileSync(file);
            } else {
                // try to get file from iobroker.socketio adapter
                let file;
                try {
                    const dir = require.resolve(`${utils.appName}.socketio`);
                    file = path.join(path.dirname(dir), '/lib/socket.io.js');
                } catch (e) {
                    // ignore
                }

                if (file && fs.existsSync(file)) {
                    socketIoFile = fs.readFileSync(file);
                } else {
                    try {
                        // try to get socket.io-client
                        const dir = require.resolve('socket.io-client');
                        const fileDir = path.join(path.dirname(dir), '../dist/');
                        if (fs.existsSync(`${fileDir}socket.io.min.js`)) {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.min.js`);
                        } else {
                            socketIoFile = fs.readFileSync(`${fileDir}socket.io.js`);
                        }
                    } catch (e) {
                        try {
                            // if nothing works, read stored in web file
                            socketIoFile = fs.readFileSync(`${__dirname}/${wwwDir}/lib/js/socket.io.js`);
                        } catch (e) {
                            adapter.log.error(`Cannot read socket.io.js: ${e}`);
                            socketIoFile = false;
                        }
                    }
                }
            }

            if (socketIoFile) {
                res.contentType('text/javascript');
                res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                return res.status(200).send(socketIoFile);
            } else {
                socketIoFile = false;
                return res.status(404).end();
            }
        }
    } else {
        next();
    }
}

function getRedirectPage(req) {
    let redirect = '../';
    let parts;
    req.body = req.body || {};
    // const isDev = req.url.includes('?dev&');

    const origin = req.body.origin || '?href=%2F';

    if (origin) {
        parts = origin.split('=');
        if (parts.length > 1 && parts[1]) {
            redirect = decodeURIComponent(parts[1]);
            // if some invalid characters in redirect
            if (redirect.match(/[^-_a-zA-Z0-9&%?./]/)) {
                redirect = '../';
            }
        }
    }

    return redirect;
}

function isInWhiteList(settings, server, req) {
    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    if (!adapter.config.auth) {
        return remoteIp;
    } else if (settings.whiteListSettings) {
        // if whitelist is used
        let whiteListIp = server.io && server.io.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
        if (!whiteListIp && server.io && remoteIp === '::1') {
            whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
        }

        if (whiteListIp && settings.whiteListSettings[whiteListIp].user !== 'auth') {
            adapter.log.silly(`whiteListIp ${whiteListIp}`);
            return whiteListIp;
        } else {
            adapter.log.debug(`Request from "${remoteIp}". Must authenticate, as IP not found in the white list`);
        }
    }

    return '';
}

async function getFoldersOfObject(path) {
    try {
        const projects = await adapter.readDirAsync(path || 'vis.0', '');
        return projects.filter(dir => dir.isDir).map(dir => dir.file);
    } catch (e) {
        adapter.log.warn(`Cannot read "${path || 'vis.0'}" directory: ${e}`);
    }

    return [];
}

async function processReadFolders(settings, req, res) {
    const params = req.url.split('?')[1];
    const query = {};
    if (params) {
        const parts = params.split('&');
        for (let p = 0; p < parts.length; p++) {
            const parts2 = parts[p].split('=');
            query[decodeURIComponent(parts2[0])] = parts2[1] === undefined ? true : decodeURIComponent(parts2[1]);
            if (query[parts2[0]] === 'true') {
                query[parts2[0]] = true;
            } else if (query[parts2[0]] === 'false') {
                query[parts2[0]] = false;
            }
        }
    }

    if (settings.auth) {
        // with basic authentication
        if (req.headers.authorization && req.headers.authorization.startsWith('Basic ')) {
            const [user, pass] = Buffer.from(req.headers.authorization.split(' ')[1], 'base64').toString().split(':');
            checkUser(user, pass, async (err, user) => {
                if (user) {
                    const list = await getFoldersOfObject(query.adapter);
                    res.json({ result: list });
                } else {
                    res.status(401).json({ error: 'Unauthorized' });
                }
            });
        } else {
            res.status(401).json({ error: 'Unauthorized' });
        }
    } else {
        const list = await getFoldersOfObject(query.adapter);
        res.json({ result: list });
    }
}

//settings: {
//    "port":   8080,
//    "auth":   false,
//    "secure": false,
//    "bind":   "0.0.0.0", // "::"
//    "cache":  false
//}
async function initWebServer(settings) {
    const server = {
        app: null,
        server: null,
        io: null,
        settings,
    };
    adapter.subscribeForeignObjects('system.config');

    settings.ttl = parseInt(settings.ttl, 10) || 3600;

    if (settings.ttl < 30) {
        settings.ttl = 30;
    }

    if (!settings.whiteListEnabled && settings.whiteListSettings) {
        delete settings.whiteListSettings;
    }

    settings.defaultUser = settings.defaultUser || 'system.user.admin';
    if (!settings.defaultUser.startsWith('system.user.')) {
        settings.defaultUser = `system.user.${settings.defaultUser}`;
    }

    if (settings.port) {
        server.app = express();
        server.app.use(compression());

        server.app.disable('x-powered-by');
        // enable use of i-frames together with HTTPS
        // todo find the admin port and bind and use it here "ALLOW-FROM ipbind:port"
        // try to add "Content-Security-Policy: frame-ancestors 'self' example.com *.example.net ;"
        /*
        server.app.get('/*', (req, res, next) => {
            res.header('X-Frame-Options' , 'SAMEORIGIN');
            next(); // http://expressjs.com/guide.html#passing-route control
        });
        */

        // replace socket.io
        server.app.use((req, res, next) => getSocketIoFile(req, res, next));

        // special end point for vis
        server.app.get('/visProjects', async (req, res) => await processReadFolders(settings, req, res));
        server.app.get('/folders', async (req, res) => await processReadFolders(settings, req, res));

        if (settings.auth) {
            initAuth(server, settings);

            /**
             * Authenticates at the server with the given username and password provided in req
             *
             * @param {object} req - request object having properties username and password
             * @param {object} res - response object
             * @param {function} next - express next function
             * @param {string} redirect - redirect path
             * @param {string} origin - origin path
             */
            const authenticate = (req, res, next, redirect, origin) => {
                passport.authenticate('local', (err, user) => {
                    // replace user
                    if (user && settings.userListEnabled) {
                        // get the user group
                        const longUser = user.startsWith('system.user.') ? user : `system.user.${user}`;
                        user = '';
                        if (settings.userListSettings.users.includes(longUser)) {
                            if (settings.userListSettings.accessAsUser) {
                                user = settings.userListSettings.accessAsUser;
                            } else {
                                user = longUser;
                            }
                        } else {
                            const groupId = Object.keys(groups).find(groupId =>
                                groups[groupId].common.members.includes(longUser),
                            );
                            if (settings.userListSettings.groups.includes(groupId)) {
                                if (settings.userListSettings.accessAsUser) {
                                    user = settings.userListSettings.accessAsUser;
                                } else {
                                    user = longUser;
                                }
                            }
                        }
                        if (!user) {
                            adapter.log.warn(`User ${longUser} is not in the user list`);
                        } else {
                            adapter.log.debug(`User ${longUser} threaded as ${user}`);
                            user = user.substring('system.user.'.length);
                        }
                    }

                    if (req.url.includes('/loginApp')) {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.status(401).json({ error: 'cannot login user' });
                        }
                        if (!user) {
                            adapter.log.warn('User not found');
                            return res.status(401).json({ error: 'cannot login user' });
                        }
                    } else {
                        if (err) {
                            adapter.log.warn(`Cannot login user: ${err}`);
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                        if (!user) {
                            return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                        }
                    }

                    req.logIn(user, err => {
                        if (req.url.includes('/loginApp')) {
                            if (err) {
                                adapter.log.warn(`Cannot login user: ${err}`);
                                return res.status(401).json({ error: 'cannot login user' });
                            }
                        } else {
                            if (err) {
                                adapter.log.warn(`Cannot login user: ${err}`);
                                return res.redirect(`/login/index.html${origin}${origin ? '&error' : '?error'}`);
                            }
                        }
                        if (req.body.stayLoggedIn) {
                            req.session.cookie.maxAge =
                                settings.ttl > ONE_MONTH_SEC ? settings.ttl * 1000 : ONE_MONTH_SEC * 1000;
                        } else {
                            req.session.cookie.maxAge = settings.ttl * 1000;
                        }
                        if (req.url.includes('/loginApp')) {
                            res.json({ result: 'ok', user });
                        } else {
                            return res.redirect(redirect);
                        }
                    });
                })(req, res, next);
            };

            /**
             * Auto Logon if possible else it will redirect or return Basic Auth information if activated
             *
             * @param {Request} req - request object
             * @param {Response} res - response object
             * @param {function} next - next function of express
             * @param {string} redirect - redirect path
             * @returns {void|*|Response}
             */
            const autoLogonOrRedirectToLogin = (req, res, next, redirect) => {
                let isJs;
                if (/\.css(\?.*)?$/.test(req.originalUrl)) {
                    res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                    return res.status(200).send('');
                } else if ((isJs = /\.js(\?.*)?$/.test(req.originalUrl))) {
                    // return always valid js file for js, because if cache is active it leads to errors
                    const parts = req.originalUrl.split('/');
                    parts.shift();

                    // if request for web/lib, ignore it, because no redirect information
                    if (parts[0] === 'lib') {
                        res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                        return res.status(200).send('');
                    }
                }

                const whiteListIp = isInWhiteList(settings, server, req);

                // if not authenticated
                if (!whiteListIp) {
                    if (isJs) {
                        return res
                            .status(200)
                            .send(
                                `document.location="${LOGIN_PAGE}?href=" + encodeURI(location.href.replace(location.origin, ""));`,
                            );
                    } else if (adapter.config.basicAuth) {
                        // if basic auth active, we tell it by sending a header with status 401
                        res.set('WWW-Authenticate', `Basic realm="Access to ioBroker web", charset="UTF-8"`);
                        return res
                            .status(401)
                            .send('Basic Authentication has been aborted. You have to reload the page.');
                    } else {
                        return res.redirect(redirect);
                    }
                }

                req.logIn(settings.whiteListSettings[whiteListIp].user, err => next(err));
            };

            server.app.post('/login', (req, res, next) => {
                let redirect = getRedirectPage(req);

                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn =
                    req.body.stayloggedin === 'true' ||
                    req.body.stayloggedin === true ||
                    req.body.stayloggedin === 'on';

                if (req.body.username && settings.addUserName && !redirect.includes('?')) {
                    const parts = redirect.split('#');
                    parts[0] += `?${req.body.username}`;
                    redirect = parts.join('#');
                }

                authenticate(req, res, next, redirect, req.body.origin || '?href=%2F');
            });

            // Login for applications to preserve cookie
            server.app.post('/loginApp', (req, res, next) => {
                req.body.password = (req.body.password || '').toString();
                req.body.username = (req.body.username || '').toString();
                req.body.stayLoggedIn =
                    req.body.stayloggedin === 'true' ||
                    req.body.stayloggedin === true ||
                    req.body.stayloggedin === 'on';

                authenticate(req, res, next, '', req.body.origin || '?href=%2F');
            });

            server.app.get('/logout', (req, res) => {
                const isDev = req.url.includes('?dev');
                req.logout(() => {
                    if (isDev) {
                        res.redirect('http://localhost:3000/index.html?login');
                    } else {
                        res.redirect(LOGIN_PAGE);
                    }
                });
            });

            // route middleware to make sure a user is logged in
            server.app.use((req, res, next) => {
                // return favicon always
                if (req.originalUrl.endsWith('favicon.ico')) {
                    res.set('Content-Type', 'image/x-icon');
                    return res.send(fs.readFileSync(`${__dirname}/${wwwDir}/login/favicon.ico`));
                }
                // if cache.manifest got back not 200 it makes an error
                if (
                    req.isAuthenticated() ||
                    /web\.\d+\/login-bg\.png(\?.*)?$/.test(req.originalUrl) ||
                    /cache\.manifest(\?.*)?$/.test(req.originalUrl) ||
                    /^\/login\//.test(req.originalUrl) ||
                    /\.ico(\?.*)?$/.test(req.originalUrl)
                ) {
                    return next();
                } else if (
                    adapter.config.basicAuth &&
                    typeof req.headers.authorization === 'string' &&
                    req.headers.authorization.startsWith('Basic')
                ) {
                    // not logged in yet, and basic auth is active + header present
                    const b64auth = req.headers.authorization.split(' ')[1];
                    const [login, password] = Buffer.from(b64auth, 'base64').toString().split(':');

                    req.body = req.body || {};

                    req.body.username = login;
                    req.body.password = password;
                    req.body.stayLoggedIn =
                        req.body.stayloggedin === 'true' ||
                        req.body.stayloggedin === true ||
                        req.body.stayloggedin === 'on';

                    const origin = req.body.origin || '?href=%2F';
                    const redirect = req.originalUrl;

                    authenticate(req, res, next, redirect, origin);
                } else {
                    // not logged in yet, redirect, auto login or send 401 if basicAuth activated
                    autoLogonOrRedirectToLogin(
                        req,
                        res,
                        next,
                        `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`,
                    );
                }
            });

            // get user by session /cookie
            server.app.get('/getUser', (req, res, next) => {
                if (req.isAuthenticated()) {
                    const parts = req.headers.cookie.split(';');
                    const cookie = {};
                    parts.forEach(item => {
                        const [name, value] = item.split('=');
                        cookie[name.trim()] = value;
                    });

                    if (cookie['connect.sid']) {
                        store?.get(
                            signature.unsign(decodeURIComponent(cookie['connect.sid']).slice(2), secret),
                            (err, obj) => {
                                // obj = {"cookie":{"originalMaxAge":2592000000,"expires":"2020-09-24T18:09:50.377Z","httpOnly":true,"path":"/"},"passport":{"user":"admin"}}
                                if (obj) {
                                    res.send({ expires: obj.cookie.expires, user: obj.passport.user });
                                } else {
                                    res.status(501).send('User not logged in.');
                                }
                            },
                        );
                    } else {
                        res.status(501).send('User not logged in.');
                    }
                } else {
                    res.status(501).send('User not logged in.');
                }
            });

            // todo
            server.app.get('/prolongSession', (req, res, next) => {
                if (req.isAuthenticated()) {
                    req.session.touch();
                    const parts = req.headers.cookie.split(';');
                    const cookie = {};
                    parts.forEach(item => {
                        const [name, value] = item.split('=');
                        cookie[name.trim()] = value;
                    });

                    if (cookie['connect.sid']) {
                        store?.get(
                            signature.unsign(decodeURIComponent(cookie['connect.sid']).slice(2), secret),
                            (err, obj) => {
                                // obj = {"cookie":{"originalMaxAge":2592000000,"expires":"2020-09-24T18:09:50.377Z","httpOnly":true,"path":"/"},"passport":{"user":"admin"}}
                                if (obj) {
                                    const expires = new Date();
                                    //expires.setMilliseconds(expires.getMilliseconds() + req.session.cookie.maxAge);

                                    obj.cookie.expires = expires.toISOString();
                                    console.log(`Session ${req.session.id} expires on ${obj.cookie.expires}`);

                                    store.set(req.session.id, obj);
                                    //res.cookie('connect.sid', cookie['connect.sid'], { maxAge: req.session.cookie.maxAge, httpOnly: true });
                                    res.send({ expires: obj.cookie.expires, user: obj.passport.user });
                                } else {
                                    res.status(501).send('cannot prolong');
                                }
                            },
                        );
                    } else {
                        res.status(501).send('cannot prolong');
                    }
                } else {
                    autoLogonOrRedirectToLogin(
                        req,
                        res,
                        next,
                        `${LOGIN_PAGE}?href=${encodeURIComponent(req.originalUrl)}`,
                    );
                }
            });
        } else {
            server.app.get('/iobroker_check.html', (req, res) => res.send('ioBroker.web'));
            server.app.get('/login', (req, res) => res.redirect('/'));
            server.app.get('/logout', (req, res) => res.redirect('/'));

            if (settings.whiteListEnabled) {
                initAuth(server, settings);
                server.app.use((req, res, next) => {
                    const remoteIp = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
                    let whiteListIp = server?.io?.getWhiteListIpForAddress(remoteIp, settings.whiteListSettings);
                    if (!whiteListIp && server.io && remoteIp === '::1') {
                        whiteListIp = server.io.getWhiteListIpForAddress('localhost', settings.whiteListSettings);
                    }
                    adapter.log.silly(`whiteListIp ${whiteListIp}`);
                    if (whiteListIp) {
                        req.logIn(settings.whiteListSettings[whiteListIp].user, err => next(err));
                    } else {
                        req.logIn(
                            settings.defaultUser.substr(12),
                            (
                                err, // cut "system.user."
                            ) => next(err),
                        );
                    }
                });
            }
        }

        if (!settings.disableStates) {
            adapter.log.debug('Activating states & socket info');
            // Init read from states
            server.app.get('/state/*', (req, res) => {
                try {
                    const fileName = req.url.split('/', 3)[2].split('?', 2);
                    adapter.getForeignObject(fileName[0], (err, obj) => {
                        let contentType = 'text/plain';
                        if (obj && obj.common.type === 'file') {
                            contentType = mime.lookup(fileName[0]);
                        }
                        if (obj && obj.common.type === 'file') {
                            const getForeignBinaryState = adapter.getForeignBinaryState || adapter.getBinaryState;
                            getForeignBinaryState.call(
                                adapter,
                                fileName[0],
                                { user: req.user ? `system.user.${req.user}` : settings.defaultUser },
                                (err, obj) => {
                                    if (!err && obj !== null && obj !== undefined) {
                                        if (
                                            obj &&
                                            typeof obj === 'object' &&
                                            obj.val !== undefined &&
                                            obj.ack !== undefined
                                        ) {
                                            res.set('Content-Type', 'application/json');
                                        } else {
                                            res.set('Content-Type', contentType || 'text/plain');
                                        }
                                        res.set('Cache-Control', 'no-cache');
                                        res.status(200).send(obj);
                                    } else {
                                        res.status(404).send(
                                            `404 Not found. File ${escapeHtml(fileName[0])} not found`,
                                        );
                                    }
                                },
                            );
                        } else {
                            adapter.getForeignState(
                                fileName[0],
                                { user: req.user ? `system.user.${req.user}` : settings.defaultUser },
                                (err, obj) => {
                                    if (!err && obj !== null && obj !== undefined) {
                                        res.set('Content-Type', 'text/plain');
                                        res.set('Cache-Control', 'no-cache');
                                        if (fileName[1] && fileName[1].includes('json')) {
                                            res.status(200).send(JSON.stringify(obj));
                                        } else {
                                            res.status(200).send(
                                                obj.val === undefined
                                                    ? 'undefined'
                                                    : obj.val === null
                                                      ? 'null'
                                                      : typeof obj.val === 'object'
                                                        ? JSON.stringify(obj.val)
                                                        : obj.val.toString(),
                                            );
                                        }
                                    } else {
                                        res.status(404).send(
                                            `404 Not found. File ${escapeHtml(fileName[0])} not found`,
                                        );
                                    }
                                },
                            );
                        }
                    });
                } catch (e) {
                    res.status(500).send(`500. Error${e}`);
                }
            });
        }

        server.app.get('*/_socket/info.js', (req, res) => {
            res.set('Content-Type', 'application/javascript');
            res.set('Cache-Control', 'no-cache');
            res.status(200).send(getInfoJs(settings));
        });

        // Enable CORS
        if (settings.socketio || adapter.common.loglevel === 'debug') {
            server.app.use((req, res, next) => {
                res.header('Access-Control-Allow-Origin', req.headers.origin || '*');
                res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
                res.header(
                    'Access-Control-Allow-Headers',
                    'Content-Type, Authorization, Content-Length, X-Requested-With, *',
                );
                res.header('Access-Control-Allow-Credentials', 'true');

                // intercept OPTIONS method
                if ('OPTIONS' === req.method) {
                    res.status(200).send(200);
                } else {
                    next();
                }
            });
        }

        const appOptions = {};
        if (settings.cache) {
            appOptions.maxAge = 30758400000; // one year
        }

        try {
            const webserver = new IoBWebServer.WebServer({ app: server.app, adapter, secure: settings.secure });
            server.server = await webserver.init();
        } catch (err) {
            adapter.log.error(`Cannot create web-server: ${err}`);
            adapter.terminate
                ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
                : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }
        if (!server.server) {
            adapter.log.error(`Cannot create web-server`);
            adapter.terminate
                ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
                : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            return;
        }

        server.server.__server = server;
    } else {
        adapter.log.error('port missing');
        adapter.terminate
            ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
            : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
    }

    if (server.server) {
        let serverListening = false;
        let serverPort;
        server.server.on('error', e => {
            if (e.toString().includes('EACCES') && serverPort <= 1024) {
                adapter.log.error(
                    `node.js process has no rights to start server on the port ${serverPort}.\n` +
                        `Do you know that on linux you need special permissions for ports under 1024?\n` +
                        `You can call in shell following scrip to allow it for node.js: "iobroker fix"`,
                );
            } else {
                adapter.log.error(`Cannot start server on ${settings.bind || '0.0.0.0'}:${serverPort}: ${e}`);
            }
            if (!serverListening) {
                adapter.terminate
                    ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
                    : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
            }
        });

        settings.port = parseInt(settings.port, 10) || 8082;
        serverPort = settings.port;

        adapter.getPort(
            settings.port,
            !settings.bind || settings.bind === '0.0.0.0' ? undefined : settings.bind || undefined,
            port => {
                port = parseInt(port, 10);
                if (port !== settings.port && !settings.findNextPort) {
                    adapter.log.error(`port ${settings.port} already in use`);
                    adapter.terminate
                        ? adapter.terminate(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION)
                        : process.exit(utils.EXIT_CODES.ADAPTER_REQUESTED_TERMINATION);
                }
                serverPort = port;
                server.server.listen(
                    port,
                    !settings.bind || settings.bind === '0.0.0.0' ? undefined : settings.bind || undefined,
                    () => {
                        serverListening = true;
                        adapter.setState('info.connection', true, true);

                        if (!settings.doNotCheckPublicIP && !settings.auth) {
                            checkTimeout = adapter.setTimeout(async () => {
                                checkTimeout = null;
                                try {
                                    await IoBWebServer.checkPublicIP(
                                        settings.port,
                                        'ioBroker.web',
                                        '/iobroker_check.html',
                                    );
                                } catch (e) {
                                    // this supported first from js-controller 5.0.
                                    adapter.sendToHost(
                                        `system.host.${adapter.host}`,
                                        'addNotification',
                                        {
                                            scope: 'system',
                                            category: 'securityIssues',
                                            message:
                                                'Your web instance is accessible from the internet without any protection. ' +
                                                'Please enable authentication or disable the access from the internet.',
                                            instance: `system.adapter.${adapter.namespace}`,
                                        },
                                        (/* result */) => {
                                            /* ignore */
                                        },
                                    );

                                    adapter.log.error(e.toString());
                                }
                            }, 1000);
                        }
                    },
                );

                adapter.log.info(`http${settings.secure ? 's' : ''} server listening on port ${port}`);
            },
        );
    }

    // Activate integrated socket
    if (ownSocket) {
        adapter.log.debug('Activating IOSocket');
        const socketSettings = JSON.parse(JSON.stringify(settings));
        // Authentication checked by server itself
        socketSettings.auth = settings.auth;
        socketSettings.secret = secret;
        socketSettings.store = store;
        socketSettings.ttl = settings.ttl || 3600;
        socketSettings.forceWebSockets = settings.forceWebSockets || false;
        socketSettings.compatibilityV2 = settings.compatibilityV2 !== false;
        socketSettings.language = settings.language;

        try {
            let filePath = settings.usePureWebSockets
                ? require.resolve(`${utils.appName}.ws`)
                : require.resolve(`${utils.appName}.socketio`);
            filePath = filePath.replace(/\\/g, '/');
            const parts = filePath.split('/');
            parts.pop(); // main.js
            parts.push('lib');
            parts.push('socket.js');
            const IOSocket = require(parts.join('/'));
            // const IOSocket = require('./lib/socket.js'); // DEBUG
            server.io = new IOSocket(server.server, socketSettings, adapter, null, store, checkUser);
        } catch (err) {
            adapter.log.error('Initialization of integrated socket.io failed. Please reinstall the web adapter.');
            if (err.message) {
                adapter.log.error(`ERROR: ${err.message}`);
                adapter.log.error(err.stack);
            } else {
                adapter.log.error(JSON.stringify(err));
            }
        }
    }

    const extensionPromises = [];

    if (!settings.disableExtensions) {
        adapter.log.debug('Activating extensions');
        // activate extensions
        Object.keys(extensions).forEach(instance => {
            try {
                // for debug purposes, try to load file in current directory "/lib/file.js" (elsewise node.js cannot debug it)
                const parts = extensions[instance].path.split('/');
                parts.shift();
                let extAPI;
                if (fs.existsSync(`./${parts.join('/')}`)) {
                    extAPI = require(`./${parts.join('/')}`);
                } else {
                    extAPI = require(`${utils.appName}.${extensions[instance].path}`);
                }

                adapter.log.info(`Connecting extension "${extensions[instance].path}"`);

                // Start web-extension
                extensions[instance].obj = new extAPI(
                    server.server,
                    { secure: settings.secure, port: settings.port },
                    adapter,
                    extensions[instance].config,
                    server.app,
                );

                if (
                    extensions[instance].obj?.waitForReady &&
                    typeof extensions[instance].obj.waitForReady === 'function'
                ) {
                    extensionPromises.push(
                        new Promise(resolve => {
                            let timeout = adapter.setTimeout(() => {
                                if (timeout) {
                                    timeout = null;
                                    adapter.log.error(
                                        `Extension "${instance}" (${extensions[instance].path}) is not responding (waitForReady)`,
                                    );
                                    resolve();
                                }
                            }, 5000);

                            const ready = () => {
                                if (timeout) {
                                    adapter.log.debug(`Connected extension "${extensions[instance].path}"`);
                                    adapter.clearTimeout(timeout);
                                    timeout = null;
                                    resolve();
                                }
                            };

                            extensions[instance].obj.waitForReady(ready);
                        }),
                    );
                }
            } catch (err) {
                adapter.log.error(`Cannot start extension "${instance}": ${err}`);
            }
        });
    }

    Promise.all(extensionPromises).then(() => {
        // Activate integrated simple API
        if (settings.simpleapi) {
            adapter.log.debug('Activating simple API');
            try {
                const SimpleAPI = require(`${utils.appName}.simple-api/lib/simpleapi.js`);

                server.api = new SimpleAPI(server.server, { secure: settings.secure, port: settings.port }, adapter);
            } catch (e) {
                adapter.log.error(`Cannot find simple api module! ${e}`);
            }
        }

        if (server.app && !settings.disableFilesObjects) {
            adapter.log.debug('Activating web files from objectDB');
            // deliver web files from objectDB
            server.app.use('/', (req, res) => {
                let url = decodeURI(req.url);
                // remove all ../
                // important: Linux does not normalize "\" but fs.readFile accepts it as '/'
                url = path.normalize(url.replace(/\\/g, '/')).replace(/\\/g, '/');
                // remove '////' at start and let only one
                if (url[0] === '/' && url[1] === '/') {
                    let i = 2;
                    while (url[i] === '/') {
                        i++;
                    }
                    url = url.substring(i - 1);
                }
                if ((url[0] === '.' && url[1] === '.') || (url[0] === '/' && url[1] === '.' && url[2] === '.')) {
                    res.status(404).send('Not found');
                    return;
                }

                if (server.api && server.api.checkRequest(url)) {
                    server.api.restApi(req, res);
                    return;
                }

                // If root directory requested
                if (url === '/' || url === '/index.html') {
                    if (adapter.config.defaultRedirect) {
                        res.redirect(301, adapter.config.defaultRedirect);
                        return;
                    } else {
                        getListOfAllAdapters(settings, server, req)
                            .then(data =>
                                res
                                    .set('Content-Type', 'text/html')
                                    .set('Cache-Control', 'no-cache')
                                    .status(200)
                                    .send(data),
                            )
                            .catch(err =>
                                res
                                    .status(500)
                                    .send(`500. Error${escapeHtml(typeof err !== 'string' ? err.toString() : err)}`),
                            );
                        return;
                    }
                }

                // add index.html
                url = url.replace(/\/($|\?|#)/, '/index.html$1');

                if (url.match(/^\/adapter\//)) {
                    // add .admin to adapter name
                    url = url.replace(/^\/adapter\/([a-zA-Z0-9-_]+)\//, '/$1.admin/');
                }

                if (url.match(/^\/lib\//)) {
                    url = `/${adapter.name}${url}`;
                }
                if (url.match(/^\/admin\//)) {
                    url = `/${adapter.name}${url}`;
                }
                url = url.split('/');
                // Skip first /
                url.shift();
                // Get ID
                const id = url.shift();
                const versionPrefix = url[0];
                url = url.join('/');
                const pos = url.indexOf('?');
                let noFileCache;
                if (pos !== -1) {
                    url = url.substring(0, pos);
                    // disable file cache if request like /vis/files/picture.png?noCache
                    noFileCache = true;
                }

                // get adapter name
                if (webByVersion[id]) {
                    if (!versionPrefix || !versionPrefix.match(/^\d+\.\d+.\d+$/)) {
                        // redirect to version
                        res.set('location', `/${id}/${webByVersion[id]}/${url}`);
                        res.status(301).send();
                        return;
                    }
                }

                if (settings.cache && cache[`${id}/${url}`] && !noFileCache) {
                    res.contentType(cache[`${id}/${url}`].mimeType);
                    if (req.headers.range) {
                        sendRange(req, res, cache[`${id}/${url}`].buffer);
                    } else {
                        res.set('Cache-Control', `public, max-age=${adapter.config.staticAssetCacheMaxAge}`);
                        res.status(200).send(cache[`${id}/${url}`].buffer);
                    }
                } else {
                    if (id === 'login' && url === 'index.html') {
                        loginPage = loginPage || prepareLoginTemplate();
                        const buffer = loginPage;

                        if (
                            !settings.auth ||
                            (req.isAuthenticated && req.isAuthenticated()) ||
                            isInWhiteList(settings, server, req)
                        ) {
                            res.redirect(getRedirectPage(req));
                            return;
                        }

                        if (buffer === null || buffer === undefined) {
                            res.contentType('text/html');
                            res.set('Cache-Control', 'no-cache');
                            res.status(200).send(`File ${escapeHtml(url)} not found`, 404);
                        } else {
                            // Store file in cache
                            if (settings.cache) {
                                cache[`${id}/${url}`] = { buffer: buffer.toString(), mimeType: 'text/html' };
                            }
                            res.set('Cache-Control', 'no-cache');
                            res.contentType('text/html');
                            res.status(200).send(buffer.toString());
                        }
                    } else {
                        // special solution for socket.io
                        if (url.endsWith('socket.io.js') || url.match(/\/socket\.io\.js(\?.*)?$/)) {
                            getSocketIoFile(req, res, true);
                            return;
                        }

                        adapter.readFile(
                            id,
                            webByVersion[id] && versionPrefix ? url.substring(versionPrefix.length + 1) : url,
                            {
                                user: req.user ? `system.user.${req.user}` : settings.defaultUser,
                                noFileCache: noFileCache,
                            },
                            (err, buffer, mimeType) => {
                                if (
                                    adapter.config.showFolderIndex &&
                                    err &&
                                    err.toString() === 'Error: Not exists' &&
                                    req.url.endsWith('/')
                                ) {
                                    url = url.replace(/\/?index.html$/, '');
                                    // show folder index

                                    const path =
                                        webByVersion[id] && versionPrefix
                                            ? url.substring(versionPrefix.length + 1)
                                            : url;
                                    return adapter.readDir(
                                        id,
                                        path,
                                        {
                                            user: req.user ? `system.user.${req.user}` : settings.defaultUser,
                                        },
                                        (err, files) => {
                                            adapter.log.debug(`readDir ${id} (${path}): ${JSON.stringify(files)}`);

                                            res.set(
                                                'Cache-Control',
                                                `public, max-age=${adapter.config.staticAssetCacheMaxAge}`,
                                            );
                                            res.set('Content-Type', 'text/html; charset=utf-8');
                                            const text = [
                                                '<html>',
                                                '<head><title>Directory</title>',
                                                `<style>body { font-family: Arial, sans-serif; } td { padding: 5px; }</style>`,
                                                `</head><body><h3>Directory ${req.url}</h3><table>`,
                                            ];

                                            if (url !== '/') {
                                                const parts = url.split('/');
                                                parts.pop();
                                                text.push(`<tr><td><a href="../">..</a></td><td></td></tr>`);
                                            }

                                            files.sort((a, b) => {
                                                if (a.isDir && b.isDir) {
                                                    return a.file.localeCompare(b.file);
                                                } else if (a.isDir) {
                                                    return -1;
                                                } else if (b.isDir) {
                                                    return 1;
                                                }

                                                return a.file.localeCompare(b.file);
                                            });
                                            files.forEach(file =>
                                                text.push(
                                                    `<tr><td><a href="./${file.file}${file.isDir ? '/' : ''}" style="${file.isDir ? 'font-weight: bold' : ''}">${file.file}</a></td><td>${(file.stats && file.stats.size) || ''}</td></tr>`,
                                                ),
                                            );
                                            text.push('</table></body></html>');
                                            res.status(200).send(text.join('\n'));
                                        },
                                    );
                                }

                                if (buffer === null || buffer === undefined || err) {
                                    res.contentType('text/html');
                                    res.status(404).send(
                                        `File ${escapeHtml(url)} not found: ${escapeHtml(typeof err !== 'string' ? JSON.stringify(err) : err)}`,
                                    );
                                } else {
                                    mimeType = mimeType || mime.lookup(url) || 'text/javascript';

                                    // replace some important variables in HTML
                                    if (url === 'index.html' || url === 'edit.html') {
                                        buffer = buffer
                                            .toString()
                                            .replaceAll(`@@vendorPrefix@@`, vendorPrefix)

                                            .replaceAll(
                                                `'@@disableDataReporting@@'`,
                                                adapter.common.disableDataReporting ? 'true' : 'false',
                                            )
                                            .replaceAll(
                                                `"@@disableDataReporting@@"`,
                                                adapter.common.disableDataReporting ? 'true' : 'false',
                                            )

                                            .replaceAll(
                                                `@@loadingBackgroundColor@@`,
                                                adapter.config.loadingBackgroundColor || '',
                                            )

                                            .replaceAll(
                                                `@@loadingBackgroundImage@@`,
                                                adapter.config.loadingBackgroundImage
                                                    ? `files/${adapter.namespace}/loading-bg.png`
                                                    : '',
                                            )

                                            .replaceAll(
                                                `'@@loadingHideLogo@@'`,
                                                adapter.config.loadingHideLogo ? 'true' : 'false',
                                            )
                                            .replaceAll(
                                                `"@@loadingHideLogo@@"`,
                                                adapter.config.loadingHideLogo ? 'true' : 'false',
                                            );
                                    }

                                    // Store file in cache
                                    if (settings.cache) {
                                        cache[`${id}/${url}`] = { buffer, mimeType };
                                    }

                                    res.contentType(mimeType);

                                    if (req.headers.range) {
                                        sendRange(req, res, buffer);
                                    } else {
                                        res.set(
                                            'Cache-Control',
                                            `public, max-age=${adapter.config.staticAssetCacheMaxAge}`,
                                        );
                                        res.status(200).send(buffer);
                                    }
                                }
                            },
                        );
                    }
                }
            });
        }
    });

    if (server.server) {
        return server;
    }

    return null;
}

// If started as allInOne/compact mode => return function to create instance
if (module && module.parent) {
    module.exports = startAdapter;
} else {
    // or start the instance directly
    startAdapter();
}
